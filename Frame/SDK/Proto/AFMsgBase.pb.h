/*****************************************************************************
// * This source file is part of ArkGameFrame                                *
// * For the latest info, see https://github.com/ArkGame                     *
// *                                                                         *
// * Copyright(c) 2013 - 2017 ArkGame authors.                               *
// *                                                                         *
// * Licensed under the Apache License, Version 2.0 (the "License");         *
// * you may not use this file except in compliance with the License.        *
// * You may obtain a copy of the License at                                 *
// *                                                                         *
// *     http://www.apache.org/licenses/LICENSE-2.0                          *
// *                                                                         *
// * Unless required by applicable law or agreed to in writing, software     *
// * distributed under the License is distributed on an "AS IS" BASIS,       *
// * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.*
// * See the License for the specific language governing permissions and     *
// * limitations under the License.                                          *
// *                                                                         *
// *                                                                         *
// * @FileName  AFMsgBase.pb.h                                                *
// * @Author    Ark Game Tech                                                *
// * @Date      2015-12-15                                                   *
// * @Module    AFMsgBase.pb                                                  *
// * @email     ArkGameTech@163.com                                          *
// * @brief     AFMsgBase.pb                                                  *
*****************************************************************************/
#ifndef PROTOBUF_AFMsgBase_2eproto__INCLUDED
#define PROTOBUF_AFMsgBase_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "AFDefine.pb.h"
// @@protoc_insertion_point(includes)

namespace AFMsg {

// Internal implementation detail -- do not call these.
void LIBPROTOC_EXPORT protobuf_AddDesc_AFMsgBase_2eproto();
void protobuf_AssignDesc_AFMsgBase_2eproto();
void protobuf_ShutdownFile_AFMsgBase_2eproto();

class Ident;
class Point3D;
class PropertyPBData;
class RecordPBData;
class PBData;
class DataListPBData;
class RecordAddRowStruct;
class ObjectRecordBase;
class ObjectPropertyList;
class MultiObjectPropertyList;
class ObjectRecordList;
class MultiObjectRecordList;
class ObjectPropertyPBData;
class ObjectRecordPBData;
class ObjectRecordSwap;
class ObjectRecordAddRow;
class ObjectRecordRemove;
class PlayerPropertyBase;
class PlayerRecordBase;
class PlayerRecordList;
class MsgBase;
class Position;
class ReqCommand;

enum ReqCommand_EGameCommandType {
  ReqCommand_EGameCommandType_EGCT_MODIY_PROPERTY = 0,
  ReqCommand_EGameCommandType_EGCT_MODIY_ITEM = 1,
  ReqCommand_EGameCommandType_EGCT_CREATE_OBJECT = 2,
  ReqCommand_EGameCommandType_EGCT_ADD_ROLE_EXP = 3
};
LIBPROTOC_EXPORT bool ReqCommand_EGameCommandType_IsValid(int value);
const ReqCommand_EGameCommandType ReqCommand_EGameCommandType_EGameCommandType_MIN = ReqCommand_EGameCommandType_EGCT_MODIY_PROPERTY;
const ReqCommand_EGameCommandType ReqCommand_EGameCommandType_EGameCommandType_MAX = ReqCommand_EGameCommandType_EGCT_ADD_ROLE_EXP;
const int ReqCommand_EGameCommandType_EGameCommandType_ARRAYSIZE = ReqCommand_EGameCommandType_EGameCommandType_MAX + 1;

LIBPROTOC_EXPORT const ::google::protobuf::EnumDescriptor* ReqCommand_EGameCommandType_descriptor();
inline const ::std::string& ReqCommand_EGameCommandType_Name(ReqCommand_EGameCommandType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ReqCommand_EGameCommandType_descriptor(), value);
}
inline bool ReqCommand_EGameCommandType_Parse(
    const ::std::string& name, ReqCommand_EGameCommandType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ReqCommand_EGameCommandType>(
    ReqCommand_EGameCommandType_descriptor(), name, value);
}
// ===================================================================

class LIBPROTOC_EXPORT Ident : public ::google::protobuf::Message {
 public:
  Ident();
  virtual ~Ident();

  Ident(const Ident& from);

  inline Ident& operator=(const Ident& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Ident& default_instance();

  void Swap(Ident* other);

  // implements Message ----------------------------------------------

  Ident* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Ident& from);
  void MergeFrom(const Ident& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 svrid = 1;
  inline bool has_svrid() const;
  inline void clear_svrid();
  static const int kSvridFieldNumber = 1;
  inline ::google::protobuf::int32 svrid() const;
  inline void set_svrid(::google::protobuf::int32 value);

  // required int32 index = 2;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 2;
  inline ::google::protobuf::int32 index() const;
  inline void set_index(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:AFMsg.Ident)
 private:
  inline void set_has_svrid();
  inline void clear_has_svrid();
  inline void set_has_index();
  inline void clear_has_index();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 svrid_;
  ::google::protobuf::int32 index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_AFMsgBase_2eproto();
  friend void protobuf_AssignDesc_AFMsgBase_2eproto();
  friend void protobuf_ShutdownFile_AFMsgBase_2eproto();

  void InitAsDefaultInstance();
  static Ident* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT Point3D : public ::google::protobuf::Message {
 public:
  Point3D();
  virtual ~Point3D();

  Point3D(const Point3D& from);

  inline Point3D& operator=(const Point3D& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Point3D& default_instance();

  void Swap(Point3D* other);

  // implements Message ----------------------------------------------

  Point3D* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Point3D& from);
  void MergeFrom(const Point3D& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline float x() const;
  inline void set_x(float value);

  // required float y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline float y() const;
  inline void set_y(float value);

  // required float z = 3;
  inline bool has_z() const;
  inline void clear_z();
  static const int kZFieldNumber = 3;
  inline float z() const;
  inline void set_z(float value);

  // @@protoc_insertion_point(class_scope:AFMsg.Point3D)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float x_;
  float y_;
  float z_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_AFMsgBase_2eproto();
  friend void protobuf_AssignDesc_AFMsgBase_2eproto();
  friend void protobuf_ShutdownFile_AFMsgBase_2eproto();

  void InitAsDefaultInstance();
  static Point3D* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT PropertyPBData : public ::google::protobuf::Message {
 public:
  PropertyPBData();
  virtual ~PropertyPBData();

  PropertyPBData(const PropertyPBData& from);

  inline PropertyPBData& operator=(const PropertyPBData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PropertyPBData& default_instance();

  void Swap(PropertyPBData* other);

  // implements Message ----------------------------------------------

  PropertyPBData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PropertyPBData& from);
  void MergeFrom(const PropertyPBData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes property_name = 1;
  inline bool has_property_name() const;
  inline void clear_property_name();
  static const int kPropertyNameFieldNumber = 1;
  inline const ::std::string& property_name() const;
  inline void set_property_name(const ::std::string& value);
  inline void set_property_name(const char* value);
  inline void set_property_name(const void* value, size_t size);
  inline ::std::string* mutable_property_name();
  inline ::std::string* release_property_name();
  inline void set_allocated_property_name(::std::string* property_name);

  // required int32 ndataType = 2;
  inline bool has_ndatatype() const;
  inline void clear_ndatatype();
  static const int kNdataTypeFieldNumber = 2;
  inline ::google::protobuf::int32 ndatatype() const;
  inline void set_ndatatype(::google::protobuf::int32 value);

  // optional bool mbValue = 3;
  inline bool has_mbvalue() const;
  inline void clear_mbvalue();
  static const int kMbValueFieldNumber = 3;
  inline bool mbvalue() const;
  inline void set_mbvalue(bool value);

  // optional int32 mnValue = 4;
  inline bool has_mnvalue() const;
  inline void clear_mnvalue();
  static const int kMnValueFieldNumber = 4;
  inline ::google::protobuf::int32 mnvalue() const;
  inline void set_mnvalue(::google::protobuf::int32 value);

  // optional int64 mn64Value = 5;
  inline bool has_mn64value() const;
  inline void clear_mn64value();
  static const int kMn64ValueFieldNumber = 5;
  inline ::google::protobuf::int64 mn64value() const;
  inline void set_mn64value(::google::protobuf::int64 value);

  // optional float mfValue = 6;
  inline bool has_mfvalue() const;
  inline void clear_mfvalue();
  static const int kMfValueFieldNumber = 6;
  inline float mfvalue() const;
  inline void set_mfvalue(float value);

  // optional double mdValue = 7;
  inline bool has_mdvalue() const;
  inline void clear_mdvalue();
  static const int kMdValueFieldNumber = 7;
  inline double mdvalue() const;
  inline void set_mdvalue(double value);

  // optional bytes mstrValue = 8;
  inline bool has_mstrvalue() const;
  inline void clear_mstrvalue();
  static const int kMstrValueFieldNumber = 8;
  inline const ::std::string& mstrvalue() const;
  inline void set_mstrvalue(const ::std::string& value);
  inline void set_mstrvalue(const char* value);
  inline void set_mstrvalue(const void* value, size_t size);
  inline ::std::string* mutable_mstrvalue();
  inline ::std::string* release_mstrvalue();
  inline void set_allocated_mstrvalue(::std::string* mstrvalue);

  // optional int64 mpVaule = 9;
  inline bool has_mpvaule() const;
  inline void clear_mpvaule();
  static const int kMpVauleFieldNumber = 9;
  inline ::google::protobuf::int64 mpvaule() const;
  inline void set_mpvaule(::google::protobuf::int64 value);

  // optional bytes mpUserData = 10;
  inline bool has_mpuserdata() const;
  inline void clear_mpuserdata();
  static const int kMpUserDataFieldNumber = 10;
  inline const ::std::string& mpuserdata() const;
  inline void set_mpuserdata(const ::std::string& value);
  inline void set_mpuserdata(const char* value);
  inline void set_mpuserdata(const void* value, size_t size);
  inline ::std::string* mutable_mpuserdata();
  inline ::std::string* release_mpuserdata();
  inline void set_allocated_mpuserdata(::std::string* mpuserdata);

  // optional .AFMsg.Ident mGuid = 11;
  inline bool has_mguid() const;
  inline void clear_mguid();
  static const int kMGuidFieldNumber = 11;
  inline const ::AFMsg::Ident& mguid() const;
  inline ::AFMsg::Ident* mutable_mguid();
  inline ::AFMsg::Ident* release_mguid();
  inline void set_allocated_mguid(::AFMsg::Ident* mguid);

  // @@protoc_insertion_point(class_scope:AFMsg.PropertyPBData)
 private:
  inline void set_has_property_name();
  inline void clear_has_property_name();
  inline void set_has_ndatatype();
  inline void clear_has_ndatatype();
  inline void set_has_mbvalue();
  inline void clear_has_mbvalue();
  inline void set_has_mnvalue();
  inline void clear_has_mnvalue();
  inline void set_has_mn64value();
  inline void clear_has_mn64value();
  inline void set_has_mfvalue();
  inline void clear_has_mfvalue();
  inline void set_has_mdvalue();
  inline void clear_has_mdvalue();
  inline void set_has_mstrvalue();
  inline void clear_has_mstrvalue();
  inline void set_has_mpvaule();
  inline void clear_has_mpvaule();
  inline void set_has_mpuserdata();
  inline void clear_has_mpuserdata();
  inline void set_has_mguid();
  inline void clear_has_mguid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* property_name_;
  ::google::protobuf::int32 ndatatype_;
  bool mbvalue_;
  ::google::protobuf::int64 mn64value_;
  ::google::protobuf::int32 mnvalue_;
  float mfvalue_;
  double mdvalue_;
  ::std::string* mstrvalue_;
  ::google::protobuf::int64 mpvaule_;
  ::std::string* mpuserdata_;
  ::AFMsg::Ident* mguid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_AFMsgBase_2eproto();
  friend void protobuf_AssignDesc_AFMsgBase_2eproto();
  friend void protobuf_ShutdownFile_AFMsgBase_2eproto();

  void InitAsDefaultInstance();
  static PropertyPBData* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT RecordPBData : public ::google::protobuf::Message {
 public:
  RecordPBData();
  virtual ~RecordPBData();

  RecordPBData(const RecordPBData& from);

  inline RecordPBData& operator=(const RecordPBData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RecordPBData& default_instance();

  void Swap(RecordPBData* other);

  // implements Message ----------------------------------------------

  RecordPBData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RecordPBData& from);
  void MergeFrom(const RecordPBData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 row = 1;
  inline bool has_row() const;
  inline void clear_row();
  static const int kRowFieldNumber = 1;
  inline ::google::protobuf::int32 row() const;
  inline void set_row(::google::protobuf::int32 value);

  // required int32 col = 2;
  inline bool has_col() const;
  inline void clear_col();
  static const int kColFieldNumber = 2;
  inline ::google::protobuf::int32 col() const;
  inline void set_col(::google::protobuf::int32 value);

  // required int32 ndataType = 3;
  inline bool has_ndatatype() const;
  inline void clear_ndatatype();
  static const int kNdataTypeFieldNumber = 3;
  inline ::google::protobuf::int32 ndatatype() const;
  inline void set_ndatatype(::google::protobuf::int32 value);

  // optional bool mbValue = 4;
  inline bool has_mbvalue() const;
  inline void clear_mbvalue();
  static const int kMbValueFieldNumber = 4;
  inline bool mbvalue() const;
  inline void set_mbvalue(bool value);

  // optional int32 mnValue = 5;
  inline bool has_mnvalue() const;
  inline void clear_mnvalue();
  static const int kMnValueFieldNumber = 5;
  inline ::google::protobuf::int32 mnvalue() const;
  inline void set_mnvalue(::google::protobuf::int32 value);

  // optional int64 mn64Value = 6;
  inline bool has_mn64value() const;
  inline void clear_mn64value();
  static const int kMn64ValueFieldNumber = 6;
  inline ::google::protobuf::int64 mn64value() const;
  inline void set_mn64value(::google::protobuf::int64 value);

  // optional float mfValue = 7;
  inline bool has_mfvalue() const;
  inline void clear_mfvalue();
  static const int kMfValueFieldNumber = 7;
  inline float mfvalue() const;
  inline void set_mfvalue(float value);

  // optional double mdValue = 8;
  inline bool has_mdvalue() const;
  inline void clear_mdvalue();
  static const int kMdValueFieldNumber = 8;
  inline double mdvalue() const;
  inline void set_mdvalue(double value);

  // optional bytes mstrValue = 9;
  inline bool has_mstrvalue() const;
  inline void clear_mstrvalue();
  static const int kMstrValueFieldNumber = 9;
  inline const ::std::string& mstrvalue() const;
  inline void set_mstrvalue(const ::std::string& value);
  inline void set_mstrvalue(const char* value);
  inline void set_mstrvalue(const void* value, size_t size);
  inline ::std::string* mutable_mstrvalue();
  inline ::std::string* release_mstrvalue();
  inline void set_allocated_mstrvalue(::std::string* mstrvalue);

  // optional int64 mpVaule = 10;
  inline bool has_mpvaule() const;
  inline void clear_mpvaule();
  static const int kMpVauleFieldNumber = 10;
  inline ::google::protobuf::int64 mpvaule() const;
  inline void set_mpvaule(::google::protobuf::int64 value);

  // optional bytes mpUserData = 11;
  inline bool has_mpuserdata() const;
  inline void clear_mpuserdata();
  static const int kMpUserDataFieldNumber = 11;
  inline const ::std::string& mpuserdata() const;
  inline void set_mpuserdata(const ::std::string& value);
  inline void set_mpuserdata(const char* value);
  inline void set_mpuserdata(const void* value, size_t size);
  inline ::std::string* mutable_mpuserdata();
  inline ::std::string* release_mpuserdata();
  inline void set_allocated_mpuserdata(::std::string* mpuserdata);

  // optional .AFMsg.Ident mGuid = 12;
  inline bool has_mguid() const;
  inline void clear_mguid();
  static const int kMGuidFieldNumber = 12;
  inline const ::AFMsg::Ident& mguid() const;
  inline ::AFMsg::Ident* mutable_mguid();
  inline ::AFMsg::Ident* release_mguid();
  inline void set_allocated_mguid(::AFMsg::Ident* mguid);

  // @@protoc_insertion_point(class_scope:AFMsg.RecordPBData)
 private:
  inline void set_has_row();
  inline void clear_has_row();
  inline void set_has_col();
  inline void clear_has_col();
  inline void set_has_ndatatype();
  inline void clear_has_ndatatype();
  inline void set_has_mbvalue();
  inline void clear_has_mbvalue();
  inline void set_has_mnvalue();
  inline void clear_has_mnvalue();
  inline void set_has_mn64value();
  inline void clear_has_mn64value();
  inline void set_has_mfvalue();
  inline void clear_has_mfvalue();
  inline void set_has_mdvalue();
  inline void clear_has_mdvalue();
  inline void set_has_mstrvalue();
  inline void clear_has_mstrvalue();
  inline void set_has_mpvaule();
  inline void clear_has_mpvaule();
  inline void set_has_mpuserdata();
  inline void clear_has_mpuserdata();
  inline void set_has_mguid();
  inline void clear_has_mguid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 row_;
  ::google::protobuf::int32 col_;
  ::google::protobuf::int32 ndatatype_;
  bool mbvalue_;
  ::google::protobuf::int64 mn64value_;
  ::google::protobuf::int32 mnvalue_;
  float mfvalue_;
  double mdvalue_;
  ::std::string* mstrvalue_;
  ::google::protobuf::int64 mpvaule_;
  ::std::string* mpuserdata_;
  ::AFMsg::Ident* mguid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_AFMsgBase_2eproto();
  friend void protobuf_AssignDesc_AFMsgBase_2eproto();
  friend void protobuf_ShutdownFile_AFMsgBase_2eproto();

  void InitAsDefaultInstance();
  static RecordPBData* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT PBData : public ::google::protobuf::Message {
 public:
  PBData();
  virtual ~PBData();

  PBData(const PBData& from);

  inline PBData& operator=(const PBData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PBData& default_instance();

  void Swap(PBData* other);

  // implements Message ----------------------------------------------

  PBData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PBData& from);
  void MergeFrom(const PBData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 ndataType = 1;
  inline bool has_ndatatype() const;
  inline void clear_ndatatype();
  static const int kNdataTypeFieldNumber = 1;
  inline ::google::protobuf::int32 ndatatype() const;
  inline void set_ndatatype(::google::protobuf::int32 value);

  // optional bool mbValue = 2;
  inline bool has_mbvalue() const;
  inline void clear_mbvalue();
  static const int kMbValueFieldNumber = 2;
  inline bool mbvalue() const;
  inline void set_mbvalue(bool value);

  // optional int32 mnValue = 3;
  inline bool has_mnvalue() const;
  inline void clear_mnvalue();
  static const int kMnValueFieldNumber = 3;
  inline ::google::protobuf::int32 mnvalue() const;
  inline void set_mnvalue(::google::protobuf::int32 value);

  // optional int64 mn64Value = 4;
  inline bool has_mn64value() const;
  inline void clear_mn64value();
  static const int kMn64ValueFieldNumber = 4;
  inline ::google::protobuf::int64 mn64value() const;
  inline void set_mn64value(::google::protobuf::int64 value);

  // optional float mfValue = 5;
  inline bool has_mfvalue() const;
  inline void clear_mfvalue();
  static const int kMfValueFieldNumber = 5;
  inline float mfvalue() const;
  inline void set_mfvalue(float value);

  // optional double mdValue = 6;
  inline bool has_mdvalue() const;
  inline void clear_mdvalue();
  static const int kMdValueFieldNumber = 6;
  inline double mdvalue() const;
  inline void set_mdvalue(double value);

  // optional bytes mstrValue = 7;
  inline bool has_mstrvalue() const;
  inline void clear_mstrvalue();
  static const int kMstrValueFieldNumber = 7;
  inline const ::std::string& mstrvalue() const;
  inline void set_mstrvalue(const ::std::string& value);
  inline void set_mstrvalue(const char* value);
  inline void set_mstrvalue(const void* value, size_t size);
  inline ::std::string* mutable_mstrvalue();
  inline ::std::string* release_mstrvalue();
  inline void set_allocated_mstrvalue(::std::string* mstrvalue);

  // optional int64 mpVaule = 8;
  inline bool has_mpvaule() const;
  inline void clear_mpvaule();
  static const int kMpVauleFieldNumber = 8;
  inline ::google::protobuf::int64 mpvaule() const;
  inline void set_mpvaule(::google::protobuf::int64 value);

  // optional bytes mpUserData = 9;
  inline bool has_mpuserdata() const;
  inline void clear_mpuserdata();
  static const int kMpUserDataFieldNumber = 9;
  inline const ::std::string& mpuserdata() const;
  inline void set_mpuserdata(const ::std::string& value);
  inline void set_mpuserdata(const char* value);
  inline void set_mpuserdata(const void* value, size_t size);
  inline ::std::string* mutable_mpuserdata();
  inline ::std::string* release_mpuserdata();
  inline void set_allocated_mpuserdata(::std::string* mpuserdata);

  // optional .AFMsg.Ident mGuid = 10;
  inline bool has_mguid() const;
  inline void clear_mguid();
  static const int kMGuidFieldNumber = 10;
  inline const ::AFMsg::Ident& mguid() const;
  inline ::AFMsg::Ident* mutable_mguid();
  inline ::AFMsg::Ident* release_mguid();
  inline void set_allocated_mguid(::AFMsg::Ident* mguid);

  // @@protoc_insertion_point(class_scope:AFMsg.PBData)
 private:
  inline void set_has_ndatatype();
  inline void clear_has_ndatatype();
  inline void set_has_mbvalue();
  inline void clear_has_mbvalue();
  inline void set_has_mnvalue();
  inline void clear_has_mnvalue();
  inline void set_has_mn64value();
  inline void clear_has_mn64value();
  inline void set_has_mfvalue();
  inline void clear_has_mfvalue();
  inline void set_has_mdvalue();
  inline void clear_has_mdvalue();
  inline void set_has_mstrvalue();
  inline void clear_has_mstrvalue();
  inline void set_has_mpvaule();
  inline void clear_has_mpvaule();
  inline void set_has_mpuserdata();
  inline void clear_has_mpuserdata();
  inline void set_has_mguid();
  inline void clear_has_mguid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 ndatatype_;
  bool mbvalue_;
  ::google::protobuf::int64 mn64value_;
  ::google::protobuf::int32 mnvalue_;
  float mfvalue_;
  double mdvalue_;
  ::std::string* mstrvalue_;
  ::google::protobuf::int64 mpvaule_;
  ::std::string* mpuserdata_;
  ::AFMsg::Ident* mguid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_AFMsgBase_2eproto();
  friend void protobuf_AssignDesc_AFMsgBase_2eproto();
  friend void protobuf_ShutdownFile_AFMsgBase_2eproto();

  void InitAsDefaultInstance();
  static PBData* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT DataListPBData : public ::google::protobuf::Message {
 public:
  DataListPBData();
  virtual ~DataListPBData();

  DataListPBData(const DataListPBData& from);

  inline DataListPBData& operator=(const DataListPBData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DataListPBData& default_instance();

  void Swap(DataListPBData* other);

  // implements Message ----------------------------------------------

  DataListPBData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DataListPBData& from);
  void MergeFrom(const DataListPBData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .AFMsg.PBData data_list = 1;
  inline int data_list_size() const;
  inline void clear_data_list();
  static const int kDataListFieldNumber = 1;
  inline const ::AFMsg::PBData& data_list(int index) const;
  inline ::AFMsg::PBData* mutable_data_list(int index);
  inline ::AFMsg::PBData* add_data_list();
  inline const ::google::protobuf::RepeatedPtrField< ::AFMsg::PBData >&
      data_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::AFMsg::PBData >*
      mutable_data_list();

  // @@protoc_insertion_point(class_scope:AFMsg.DataListPBData)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::AFMsg::PBData > data_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_AFMsgBase_2eproto();
  friend void protobuf_AssignDesc_AFMsgBase_2eproto();
  friend void protobuf_ShutdownFile_AFMsgBase_2eproto();

  void InitAsDefaultInstance();
  static DataListPBData* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT RecordAddRowStruct : public ::google::protobuf::Message {
 public:
  RecordAddRowStruct();
  virtual ~RecordAddRowStruct();

  RecordAddRowStruct(const RecordAddRowStruct& from);

  inline RecordAddRowStruct& operator=(const RecordAddRowStruct& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RecordAddRowStruct& default_instance();

  void Swap(RecordAddRowStruct* other);

  // implements Message ----------------------------------------------

  RecordAddRowStruct* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RecordAddRowStruct& from);
  void MergeFrom(const RecordAddRowStruct& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 row = 1;
  inline bool has_row() const;
  inline void clear_row();
  static const int kRowFieldNumber = 1;
  inline ::google::protobuf::int32 row() const;
  inline void set_row(::google::protobuf::int32 value);

  // repeated .AFMsg.RecordPBData record_data_list = 2;
  inline int record_data_list_size() const;
  inline void clear_record_data_list();
  static const int kRecordDataListFieldNumber = 2;
  inline const ::AFMsg::RecordPBData& record_data_list(int index) const;
  inline ::AFMsg::RecordPBData* mutable_record_data_list(int index);
  inline ::AFMsg::RecordPBData* add_record_data_list();
  inline const ::google::protobuf::RepeatedPtrField< ::AFMsg::RecordPBData >&
      record_data_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::AFMsg::RecordPBData >*
      mutable_record_data_list();

  // @@protoc_insertion_point(class_scope:AFMsg.RecordAddRowStruct)
 private:
  inline void set_has_row();
  inline void clear_has_row();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::AFMsg::RecordPBData > record_data_list_;
  ::google::protobuf::int32 row_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_AFMsgBase_2eproto();
  friend void protobuf_AssignDesc_AFMsgBase_2eproto();
  friend void protobuf_ShutdownFile_AFMsgBase_2eproto();

  void InitAsDefaultInstance();
  static RecordAddRowStruct* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT ObjectRecordBase : public ::google::protobuf::Message {
 public:
  ObjectRecordBase();
  virtual ~ObjectRecordBase();

  ObjectRecordBase(const ObjectRecordBase& from);

  inline ObjectRecordBase& operator=(const ObjectRecordBase& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ObjectRecordBase& default_instance();

  void Swap(ObjectRecordBase* other);

  // implements Message ----------------------------------------------

  ObjectRecordBase* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ObjectRecordBase& from);
  void MergeFrom(const ObjectRecordBase& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes record_name = 1;
  inline bool has_record_name() const;
  inline void clear_record_name();
  static const int kRecordNameFieldNumber = 1;
  inline const ::std::string& record_name() const;
  inline void set_record_name(const ::std::string& value);
  inline void set_record_name(const char* value);
  inline void set_record_name(const void* value, size_t size);
  inline ::std::string* mutable_record_name();
  inline ::std::string* release_record_name();
  inline void set_allocated_record_name(::std::string* record_name);

  // repeated .AFMsg.RecordAddRowStruct row_struct = 2;
  inline int row_struct_size() const;
  inline void clear_row_struct();
  static const int kRowStructFieldNumber = 2;
  inline const ::AFMsg::RecordAddRowStruct& row_struct(int index) const;
  inline ::AFMsg::RecordAddRowStruct* mutable_row_struct(int index);
  inline ::AFMsg::RecordAddRowStruct* add_row_struct();
  inline const ::google::protobuf::RepeatedPtrField< ::AFMsg::RecordAddRowStruct >&
      row_struct() const;
  inline ::google::protobuf::RepeatedPtrField< ::AFMsg::RecordAddRowStruct >*
      mutable_row_struct();

  // @@protoc_insertion_point(class_scope:AFMsg.ObjectRecordBase)
 private:
  inline void set_has_record_name();
  inline void clear_has_record_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* record_name_;
  ::google::protobuf::RepeatedPtrField< ::AFMsg::RecordAddRowStruct > row_struct_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_AFMsgBase_2eproto();
  friend void protobuf_AssignDesc_AFMsgBase_2eproto();
  friend void protobuf_ShutdownFile_AFMsgBase_2eproto();

  void InitAsDefaultInstance();
  static ObjectRecordBase* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT ObjectPropertyList : public ::google::protobuf::Message {
 public:
  ObjectPropertyList();
  virtual ~ObjectPropertyList();

  ObjectPropertyList(const ObjectPropertyList& from);

  inline ObjectPropertyList& operator=(const ObjectPropertyList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ObjectPropertyList& default_instance();

  void Swap(ObjectPropertyList* other);

  // implements Message ----------------------------------------------

  ObjectPropertyList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ObjectPropertyList& from);
  void MergeFrom(const ObjectPropertyList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .AFMsg.Ident player_id = 1;
  inline bool has_player_id() const;
  inline void clear_player_id();
  static const int kPlayerIdFieldNumber = 1;
  inline const ::AFMsg::Ident& player_id() const;
  inline ::AFMsg::Ident* mutable_player_id();
  inline ::AFMsg::Ident* release_player_id();
  inline void set_allocated_player_id(::AFMsg::Ident* player_id);

  // repeated .AFMsg.PropertyPBData property_data_list = 2;
  inline int property_data_list_size() const;
  inline void clear_property_data_list();
  static const int kPropertyDataListFieldNumber = 2;
  inline const ::AFMsg::PropertyPBData& property_data_list(int index) const;
  inline ::AFMsg::PropertyPBData* mutable_property_data_list(int index);
  inline ::AFMsg::PropertyPBData* add_property_data_list();
  inline const ::google::protobuf::RepeatedPtrField< ::AFMsg::PropertyPBData >&
      property_data_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::AFMsg::PropertyPBData >*
      mutable_property_data_list();

  // @@protoc_insertion_point(class_scope:AFMsg.ObjectPropertyList)
 private:
  inline void set_has_player_id();
  inline void clear_has_player_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::AFMsg::Ident* player_id_;
  ::google::protobuf::RepeatedPtrField< ::AFMsg::PropertyPBData > property_data_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_AFMsgBase_2eproto();
  friend void protobuf_AssignDesc_AFMsgBase_2eproto();
  friend void protobuf_ShutdownFile_AFMsgBase_2eproto();

  void InitAsDefaultInstance();
  static ObjectPropertyList* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT MultiObjectPropertyList : public ::google::protobuf::Message {
 public:
  MultiObjectPropertyList();
  virtual ~MultiObjectPropertyList();

  MultiObjectPropertyList(const MultiObjectPropertyList& from);

  inline MultiObjectPropertyList& operator=(const MultiObjectPropertyList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MultiObjectPropertyList& default_instance();

  void Swap(MultiObjectPropertyList* other);

  // implements Message ----------------------------------------------

  MultiObjectPropertyList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MultiObjectPropertyList& from);
  void MergeFrom(const MultiObjectPropertyList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .AFMsg.ObjectPropertyList multi_player_property = 1;
  inline int multi_player_property_size() const;
  inline void clear_multi_player_property();
  static const int kMultiPlayerPropertyFieldNumber = 1;
  inline const ::AFMsg::ObjectPropertyList& multi_player_property(int index) const;
  inline ::AFMsg::ObjectPropertyList* mutable_multi_player_property(int index);
  inline ::AFMsg::ObjectPropertyList* add_multi_player_property();
  inline const ::google::protobuf::RepeatedPtrField< ::AFMsg::ObjectPropertyList >&
      multi_player_property() const;
  inline ::google::protobuf::RepeatedPtrField< ::AFMsg::ObjectPropertyList >*
      mutable_multi_player_property();

  // @@protoc_insertion_point(class_scope:AFMsg.MultiObjectPropertyList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::AFMsg::ObjectPropertyList > multi_player_property_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_AFMsgBase_2eproto();
  friend void protobuf_AssignDesc_AFMsgBase_2eproto();
  friend void protobuf_ShutdownFile_AFMsgBase_2eproto();

  void InitAsDefaultInstance();
  static MultiObjectPropertyList* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT ObjectRecordList : public ::google::protobuf::Message {
 public:
  ObjectRecordList();
  virtual ~ObjectRecordList();

  ObjectRecordList(const ObjectRecordList& from);

  inline ObjectRecordList& operator=(const ObjectRecordList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ObjectRecordList& default_instance();

  void Swap(ObjectRecordList* other);

  // implements Message ----------------------------------------------

  ObjectRecordList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ObjectRecordList& from);
  void MergeFrom(const ObjectRecordList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .AFMsg.Ident player_id = 1;
  inline bool has_player_id() const;
  inline void clear_player_id();
  static const int kPlayerIdFieldNumber = 1;
  inline const ::AFMsg::Ident& player_id() const;
  inline ::AFMsg::Ident* mutable_player_id();
  inline ::AFMsg::Ident* release_player_id();
  inline void set_allocated_player_id(::AFMsg::Ident* player_id);

  // repeated .AFMsg.ObjectRecordBase record_list = 2;
  inline int record_list_size() const;
  inline void clear_record_list();
  static const int kRecordListFieldNumber = 2;
  inline const ::AFMsg::ObjectRecordBase& record_list(int index) const;
  inline ::AFMsg::ObjectRecordBase* mutable_record_list(int index);
  inline ::AFMsg::ObjectRecordBase* add_record_list();
  inline const ::google::protobuf::RepeatedPtrField< ::AFMsg::ObjectRecordBase >&
      record_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::AFMsg::ObjectRecordBase >*
      mutable_record_list();

  // @@protoc_insertion_point(class_scope:AFMsg.ObjectRecordList)
 private:
  inline void set_has_player_id();
  inline void clear_has_player_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::AFMsg::Ident* player_id_;
  ::google::protobuf::RepeatedPtrField< ::AFMsg::ObjectRecordBase > record_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_AFMsgBase_2eproto();
  friend void protobuf_AssignDesc_AFMsgBase_2eproto();
  friend void protobuf_ShutdownFile_AFMsgBase_2eproto();

  void InitAsDefaultInstance();
  static ObjectRecordList* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT MultiObjectRecordList : public ::google::protobuf::Message {
 public:
  MultiObjectRecordList();
  virtual ~MultiObjectRecordList();

  MultiObjectRecordList(const MultiObjectRecordList& from);

  inline MultiObjectRecordList& operator=(const MultiObjectRecordList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MultiObjectRecordList& default_instance();

  void Swap(MultiObjectRecordList* other);

  // implements Message ----------------------------------------------

  MultiObjectRecordList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MultiObjectRecordList& from);
  void MergeFrom(const MultiObjectRecordList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .AFMsg.ObjectRecordList multi_player_record = 1;
  inline int multi_player_record_size() const;
  inline void clear_multi_player_record();
  static const int kMultiPlayerRecordFieldNumber = 1;
  inline const ::AFMsg::ObjectRecordList& multi_player_record(int index) const;
  inline ::AFMsg::ObjectRecordList* mutable_multi_player_record(int index);
  inline ::AFMsg::ObjectRecordList* add_multi_player_record();
  inline const ::google::protobuf::RepeatedPtrField< ::AFMsg::ObjectRecordList >&
      multi_player_record() const;
  inline ::google::protobuf::RepeatedPtrField< ::AFMsg::ObjectRecordList >*
      mutable_multi_player_record();

  // @@protoc_insertion_point(class_scope:AFMsg.MultiObjectRecordList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::AFMsg::ObjectRecordList > multi_player_record_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_AFMsgBase_2eproto();
  friend void protobuf_AssignDesc_AFMsgBase_2eproto();
  friend void protobuf_ShutdownFile_AFMsgBase_2eproto();

  void InitAsDefaultInstance();
  static MultiObjectRecordList* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT ObjectPropertyPBData : public ::google::protobuf::Message {
 public:
  ObjectPropertyPBData();
  virtual ~ObjectPropertyPBData();

  ObjectPropertyPBData(const ObjectPropertyPBData& from);

  inline ObjectPropertyPBData& operator=(const ObjectPropertyPBData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ObjectPropertyPBData& default_instance();

  void Swap(ObjectPropertyPBData* other);

  // implements Message ----------------------------------------------

  ObjectPropertyPBData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ObjectPropertyPBData& from);
  void MergeFrom(const ObjectPropertyPBData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .AFMsg.Ident player_id = 1;
  inline bool has_player_id() const;
  inline void clear_player_id();
  static const int kPlayerIdFieldNumber = 1;
  inline const ::AFMsg::Ident& player_id() const;
  inline ::AFMsg::Ident* mutable_player_id();
  inline ::AFMsg::Ident* release_player_id();
  inline void set_allocated_player_id(::AFMsg::Ident* player_id);

  // repeated .AFMsg.PropertyPBData property_list = 2;
  inline int property_list_size() const;
  inline void clear_property_list();
  static const int kPropertyListFieldNumber = 2;
  inline const ::AFMsg::PropertyPBData& property_list(int index) const;
  inline ::AFMsg::PropertyPBData* mutable_property_list(int index);
  inline ::AFMsg::PropertyPBData* add_property_list();
  inline const ::google::protobuf::RepeatedPtrField< ::AFMsg::PropertyPBData >&
      property_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::AFMsg::PropertyPBData >*
      mutable_property_list();

  // @@protoc_insertion_point(class_scope:AFMsg.ObjectPropertyPBData)
 private:
  inline void set_has_player_id();
  inline void clear_has_player_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::AFMsg::Ident* player_id_;
  ::google::protobuf::RepeatedPtrField< ::AFMsg::PropertyPBData > property_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_AFMsgBase_2eproto();
  friend void protobuf_AssignDesc_AFMsgBase_2eproto();
  friend void protobuf_ShutdownFile_AFMsgBase_2eproto();

  void InitAsDefaultInstance();
  static ObjectPropertyPBData* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT ObjectRecordPBData : public ::google::protobuf::Message {
 public:
  ObjectRecordPBData();
  virtual ~ObjectRecordPBData();

  ObjectRecordPBData(const ObjectRecordPBData& from);

  inline ObjectRecordPBData& operator=(const ObjectRecordPBData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ObjectRecordPBData& default_instance();

  void Swap(ObjectRecordPBData* other);

  // implements Message ----------------------------------------------

  ObjectRecordPBData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ObjectRecordPBData& from);
  void MergeFrom(const ObjectRecordPBData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .AFMsg.Ident player_id = 1;
  inline bool has_player_id() const;
  inline void clear_player_id();
  static const int kPlayerIdFieldNumber = 1;
  inline const ::AFMsg::Ident& player_id() const;
  inline ::AFMsg::Ident* mutable_player_id();
  inline ::AFMsg::Ident* release_player_id();
  inline void set_allocated_player_id(::AFMsg::Ident* player_id);

  // required bytes record_name = 2;
  inline bool has_record_name() const;
  inline void clear_record_name();
  static const int kRecordNameFieldNumber = 2;
  inline const ::std::string& record_name() const;
  inline void set_record_name(const ::std::string& value);
  inline void set_record_name(const char* value);
  inline void set_record_name(const void* value, size_t size);
  inline ::std::string* mutable_record_name();
  inline ::std::string* release_record_name();
  inline void set_allocated_record_name(::std::string* record_name);

  // repeated .AFMsg.RecordPBData record_list = 3;
  inline int record_list_size() const;
  inline void clear_record_list();
  static const int kRecordListFieldNumber = 3;
  inline const ::AFMsg::RecordPBData& record_list(int index) const;
  inline ::AFMsg::RecordPBData* mutable_record_list(int index);
  inline ::AFMsg::RecordPBData* add_record_list();
  inline const ::google::protobuf::RepeatedPtrField< ::AFMsg::RecordPBData >&
      record_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::AFMsg::RecordPBData >*
      mutable_record_list();

  // @@protoc_insertion_point(class_scope:AFMsg.ObjectRecordPBData)
 private:
  inline void set_has_player_id();
  inline void clear_has_player_id();
  inline void set_has_record_name();
  inline void clear_has_record_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::AFMsg::Ident* player_id_;
  ::std::string* record_name_;
  ::google::protobuf::RepeatedPtrField< ::AFMsg::RecordPBData > record_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_AFMsgBase_2eproto();
  friend void protobuf_AssignDesc_AFMsgBase_2eproto();
  friend void protobuf_ShutdownFile_AFMsgBase_2eproto();

  void InitAsDefaultInstance();
  static ObjectRecordPBData* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT ObjectRecordSwap : public ::google::protobuf::Message {
 public:
  ObjectRecordSwap();
  virtual ~ObjectRecordSwap();

  ObjectRecordSwap(const ObjectRecordSwap& from);

  inline ObjectRecordSwap& operator=(const ObjectRecordSwap& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ObjectRecordSwap& default_instance();

  void Swap(ObjectRecordSwap* other);

  // implements Message ----------------------------------------------

  ObjectRecordSwap* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ObjectRecordSwap& from);
  void MergeFrom(const ObjectRecordSwap& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .AFMsg.Ident player_id = 1;
  inline bool has_player_id() const;
  inline void clear_player_id();
  static const int kPlayerIdFieldNumber = 1;
  inline const ::AFMsg::Ident& player_id() const;
  inline ::AFMsg::Ident* mutable_player_id();
  inline ::AFMsg::Ident* release_player_id();
  inline void set_allocated_player_id(::AFMsg::Ident* player_id);

  // required bytes origin_record_name = 2;
  inline bool has_origin_record_name() const;
  inline void clear_origin_record_name();
  static const int kOriginRecordNameFieldNumber = 2;
  inline const ::std::string& origin_record_name() const;
  inline void set_origin_record_name(const ::std::string& value);
  inline void set_origin_record_name(const char* value);
  inline void set_origin_record_name(const void* value, size_t size);
  inline ::std::string* mutable_origin_record_name();
  inline ::std::string* release_origin_record_name();
  inline void set_allocated_origin_record_name(::std::string* origin_record_name);

  // optional bytes target_record_name = 3;
  inline bool has_target_record_name() const;
  inline void clear_target_record_name();
  static const int kTargetRecordNameFieldNumber = 3;
  inline const ::std::string& target_record_name() const;
  inline void set_target_record_name(const ::std::string& value);
  inline void set_target_record_name(const char* value);
  inline void set_target_record_name(const void* value, size_t size);
  inline ::std::string* mutable_target_record_name();
  inline ::std::string* release_target_record_name();
  inline void set_allocated_target_record_name(::std::string* target_record_name);

  // required int32 row_origin = 4;
  inline bool has_row_origin() const;
  inline void clear_row_origin();
  static const int kRowOriginFieldNumber = 4;
  inline ::google::protobuf::int32 row_origin() const;
  inline void set_row_origin(::google::protobuf::int32 value);

  // required int32 row_target = 5;
  inline bool has_row_target() const;
  inline void clear_row_target();
  static const int kRowTargetFieldNumber = 5;
  inline ::google::protobuf::int32 row_target() const;
  inline void set_row_target(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:AFMsg.ObjectRecordSwap)
 private:
  inline void set_has_player_id();
  inline void clear_has_player_id();
  inline void set_has_origin_record_name();
  inline void clear_has_origin_record_name();
  inline void set_has_target_record_name();
  inline void clear_has_target_record_name();
  inline void set_has_row_origin();
  inline void clear_has_row_origin();
  inline void set_has_row_target();
  inline void clear_has_row_target();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::AFMsg::Ident* player_id_;
  ::std::string* origin_record_name_;
  ::std::string* target_record_name_;
  ::google::protobuf::int32 row_origin_;
  ::google::protobuf::int32 row_target_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_AFMsgBase_2eproto();
  friend void protobuf_AssignDesc_AFMsgBase_2eproto();
  friend void protobuf_ShutdownFile_AFMsgBase_2eproto();

  void InitAsDefaultInstance();
  static ObjectRecordSwap* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT ObjectRecordAddRow : public ::google::protobuf::Message {
 public:
  ObjectRecordAddRow();
  virtual ~ObjectRecordAddRow();

  ObjectRecordAddRow(const ObjectRecordAddRow& from);

  inline ObjectRecordAddRow& operator=(const ObjectRecordAddRow& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ObjectRecordAddRow& default_instance();

  void Swap(ObjectRecordAddRow* other);

  // implements Message ----------------------------------------------

  ObjectRecordAddRow* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ObjectRecordAddRow& from);
  void MergeFrom(const ObjectRecordAddRow& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .AFMsg.Ident player_id = 1;
  inline bool has_player_id() const;
  inline void clear_player_id();
  static const int kPlayerIdFieldNumber = 1;
  inline const ::AFMsg::Ident& player_id() const;
  inline ::AFMsg::Ident* mutable_player_id();
  inline ::AFMsg::Ident* release_player_id();
  inline void set_allocated_player_id(::AFMsg::Ident* player_id);

  // required bytes record_name = 2;
  inline bool has_record_name() const;
  inline void clear_record_name();
  static const int kRecordNameFieldNumber = 2;
  inline const ::std::string& record_name() const;
  inline void set_record_name(const ::std::string& value);
  inline void set_record_name(const char* value);
  inline void set_record_name(const void* value, size_t size);
  inline ::std::string* mutable_record_name();
  inline ::std::string* release_record_name();
  inline void set_allocated_record_name(::std::string* record_name);

  // repeated .AFMsg.RecordAddRowStruct row_data = 3;
  inline int row_data_size() const;
  inline void clear_row_data();
  static const int kRowDataFieldNumber = 3;
  inline const ::AFMsg::RecordAddRowStruct& row_data(int index) const;
  inline ::AFMsg::RecordAddRowStruct* mutable_row_data(int index);
  inline ::AFMsg::RecordAddRowStruct* add_row_data();
  inline const ::google::protobuf::RepeatedPtrField< ::AFMsg::RecordAddRowStruct >&
      row_data() const;
  inline ::google::protobuf::RepeatedPtrField< ::AFMsg::RecordAddRowStruct >*
      mutable_row_data();

  // @@protoc_insertion_point(class_scope:AFMsg.ObjectRecordAddRow)
 private:
  inline void set_has_player_id();
  inline void clear_has_player_id();
  inline void set_has_record_name();
  inline void clear_has_record_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::AFMsg::Ident* player_id_;
  ::std::string* record_name_;
  ::google::protobuf::RepeatedPtrField< ::AFMsg::RecordAddRowStruct > row_data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_AFMsgBase_2eproto();
  friend void protobuf_AssignDesc_AFMsgBase_2eproto();
  friend void protobuf_ShutdownFile_AFMsgBase_2eproto();

  void InitAsDefaultInstance();
  static ObjectRecordAddRow* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT ObjectRecordRemove : public ::google::protobuf::Message {
 public:
  ObjectRecordRemove();
  virtual ~ObjectRecordRemove();

  ObjectRecordRemove(const ObjectRecordRemove& from);

  inline ObjectRecordRemove& operator=(const ObjectRecordRemove& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ObjectRecordRemove& default_instance();

  void Swap(ObjectRecordRemove* other);

  // implements Message ----------------------------------------------

  ObjectRecordRemove* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ObjectRecordRemove& from);
  void MergeFrom(const ObjectRecordRemove& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .AFMsg.Ident player_id = 1;
  inline bool has_player_id() const;
  inline void clear_player_id();
  static const int kPlayerIdFieldNumber = 1;
  inline const ::AFMsg::Ident& player_id() const;
  inline ::AFMsg::Ident* mutable_player_id();
  inline ::AFMsg::Ident* release_player_id();
  inline void set_allocated_player_id(::AFMsg::Ident* player_id);

  // required bytes record_name = 2;
  inline bool has_record_name() const;
  inline void clear_record_name();
  static const int kRecordNameFieldNumber = 2;
  inline const ::std::string& record_name() const;
  inline void set_record_name(const ::std::string& value);
  inline void set_record_name(const char* value);
  inline void set_record_name(const void* value, size_t size);
  inline ::std::string* mutable_record_name();
  inline ::std::string* release_record_name();
  inline void set_allocated_record_name(::std::string* record_name);

  // repeated int32 remove_row = 3;
  inline int remove_row_size() const;
  inline void clear_remove_row();
  static const int kRemoveRowFieldNumber = 3;
  inline ::google::protobuf::int32 remove_row(int index) const;
  inline void set_remove_row(int index, ::google::protobuf::int32 value);
  inline void add_remove_row(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      remove_row() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_remove_row();

  // @@protoc_insertion_point(class_scope:AFMsg.ObjectRecordRemove)
 private:
  inline void set_has_player_id();
  inline void clear_has_player_id();
  inline void set_has_record_name();
  inline void clear_has_record_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::AFMsg::Ident* player_id_;
  ::std::string* record_name_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > remove_row_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_AFMsgBase_2eproto();
  friend void protobuf_AssignDesc_AFMsgBase_2eproto();
  friend void protobuf_ShutdownFile_AFMsgBase_2eproto();

  void InitAsDefaultInstance();
  static ObjectRecordRemove* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT PlayerPropertyBase : public ::google::protobuf::Message {
 public:
  PlayerPropertyBase();
  virtual ~PlayerPropertyBase();

  PlayerPropertyBase(const PlayerPropertyBase& from);

  inline PlayerPropertyBase& operator=(const PlayerPropertyBase& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerPropertyBase& default_instance();

  void Swap(PlayerPropertyBase* other);

  // implements Message ----------------------------------------------

  PlayerPropertyBase* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerPropertyBase& from);
  void MergeFrom(const PlayerPropertyBase& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .AFMsg.PropertyPBData property_data_list = 1;
  inline int property_data_list_size() const;
  inline void clear_property_data_list();
  static const int kPropertyDataListFieldNumber = 1;
  inline const ::AFMsg::PropertyPBData& property_data_list(int index) const;
  inline ::AFMsg::PropertyPBData* mutable_property_data_list(int index);
  inline ::AFMsg::PropertyPBData* add_property_data_list();
  inline const ::google::protobuf::RepeatedPtrField< ::AFMsg::PropertyPBData >&
      property_data_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::AFMsg::PropertyPBData >*
      mutable_property_data_list();

  // @@protoc_insertion_point(class_scope:AFMsg.PlayerPropertyBase)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::AFMsg::PropertyPBData > property_data_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_AFMsgBase_2eproto();
  friend void protobuf_AssignDesc_AFMsgBase_2eproto();
  friend void protobuf_ShutdownFile_AFMsgBase_2eproto();

  void InitAsDefaultInstance();
  static PlayerPropertyBase* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT PlayerRecordBase : public ::google::protobuf::Message {
 public:
  PlayerRecordBase();
  virtual ~PlayerRecordBase();

  PlayerRecordBase(const PlayerRecordBase& from);

  inline PlayerRecordBase& operator=(const PlayerRecordBase& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerRecordBase& default_instance();

  void Swap(PlayerRecordBase* other);

  // implements Message ----------------------------------------------

  PlayerRecordBase* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerRecordBase& from);
  void MergeFrom(const PlayerRecordBase& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string record_name = 1;
  inline bool has_record_name() const;
  inline void clear_record_name();
  static const int kRecordNameFieldNumber = 1;
  inline const ::std::string& record_name() const;
  inline void set_record_name(const ::std::string& value);
  inline void set_record_name(const char* value);
  inline void set_record_name(const char* value, size_t size);
  inline ::std::string* mutable_record_name();
  inline ::std::string* release_record_name();
  inline void set_allocated_record_name(::std::string* record_name);

  // repeated .AFMsg.RecordPBData record_data_list = 2;
  inline int record_data_list_size() const;
  inline void clear_record_data_list();
  static const int kRecordDataListFieldNumber = 2;
  inline const ::AFMsg::RecordPBData& record_data_list(int index) const;
  inline ::AFMsg::RecordPBData* mutable_record_data_list(int index);
  inline ::AFMsg::RecordPBData* add_record_data_list();
  inline const ::google::protobuf::RepeatedPtrField< ::AFMsg::RecordPBData >&
      record_data_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::AFMsg::RecordPBData >*
      mutable_record_data_list();

  // @@protoc_insertion_point(class_scope:AFMsg.PlayerRecordBase)
 private:
  inline void set_has_record_name();
  inline void clear_has_record_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* record_name_;
  ::google::protobuf::RepeatedPtrField< ::AFMsg::RecordPBData > record_data_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_AFMsgBase_2eproto();
  friend void protobuf_AssignDesc_AFMsgBase_2eproto();
  friend void protobuf_ShutdownFile_AFMsgBase_2eproto();

  void InitAsDefaultInstance();
  static PlayerRecordBase* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT PlayerRecordList : public ::google::protobuf::Message {
 public:
  PlayerRecordList();
  virtual ~PlayerRecordList();

  PlayerRecordList(const PlayerRecordList& from);

  inline PlayerRecordList& operator=(const PlayerRecordList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerRecordList& default_instance();

  void Swap(PlayerRecordList* other);

  // implements Message ----------------------------------------------

  PlayerRecordList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerRecordList& from);
  void MergeFrom(const PlayerRecordList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .AFMsg.PlayerRecordBase record_list = 1;
  inline int record_list_size() const;
  inline void clear_record_list();
  static const int kRecordListFieldNumber = 1;
  inline const ::AFMsg::PlayerRecordBase& record_list(int index) const;
  inline ::AFMsg::PlayerRecordBase* mutable_record_list(int index);
  inline ::AFMsg::PlayerRecordBase* add_record_list();
  inline const ::google::protobuf::RepeatedPtrField< ::AFMsg::PlayerRecordBase >&
      record_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::AFMsg::PlayerRecordBase >*
      mutable_record_list();

  // @@protoc_insertion_point(class_scope:AFMsg.PlayerRecordList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::AFMsg::PlayerRecordBase > record_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_AFMsgBase_2eproto();
  friend void protobuf_AssignDesc_AFMsgBase_2eproto();
  friend void protobuf_ShutdownFile_AFMsgBase_2eproto();

  void InitAsDefaultInstance();
  static PlayerRecordList* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT MsgBase : public ::google::protobuf::Message {
 public:
  MsgBase();
  virtual ~MsgBase();

  MsgBase(const MsgBase& from);

  inline MsgBase& operator=(const MsgBase& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgBase& default_instance();

  void Swap(MsgBase* other);

  // implements Message ----------------------------------------------

  MsgBase* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgBase& from);
  void MergeFrom(const MsgBase& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .AFMsg.Ident player_id = 1;
  inline bool has_player_id() const;
  inline void clear_player_id();
  static const int kPlayerIdFieldNumber = 1;
  inline const ::AFMsg::Ident& player_id() const;
  inline ::AFMsg::Ident* mutable_player_id();
  inline ::AFMsg::Ident* release_player_id();
  inline void set_allocated_player_id(::AFMsg::Ident* player_id);

  // required bytes msg_data = 2;
  inline bool has_msg_data() const;
  inline void clear_msg_data();
  static const int kMsgDataFieldNumber = 2;
  inline const ::std::string& msg_data() const;
  inline void set_msg_data(const ::std::string& value);
  inline void set_msg_data(const char* value);
  inline void set_msg_data(const void* value, size_t size);
  inline ::std::string* mutable_msg_data();
  inline ::std::string* release_msg_data();
  inline void set_allocated_msg_data(::std::string* msg_data);

  // repeated .AFMsg.Ident player_Client_list = 3;
  inline int player_client_list_size() const;
  inline void clear_player_client_list();
  static const int kPlayerClientListFieldNumber = 3;
  inline const ::AFMsg::Ident& player_client_list(int index) const;
  inline ::AFMsg::Ident* mutable_player_client_list(int index);
  inline ::AFMsg::Ident* add_player_client_list();
  inline const ::google::protobuf::RepeatedPtrField< ::AFMsg::Ident >&
      player_client_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::AFMsg::Ident >*
      mutable_player_client_list();

  // optional .AFMsg.Ident hash_ident = 4;
  inline bool has_hash_ident() const;
  inline void clear_hash_ident();
  static const int kHashIdentFieldNumber = 4;
  inline const ::AFMsg::Ident& hash_ident() const;
  inline ::AFMsg::Ident* mutable_hash_ident();
  inline ::AFMsg::Ident* release_hash_ident();
  inline void set_allocated_hash_ident(::AFMsg::Ident* hash_ident);

  // @@protoc_insertion_point(class_scope:AFMsg.MsgBase)
 private:
  inline void set_has_player_id();
  inline void clear_has_player_id();
  inline void set_has_msg_data();
  inline void clear_has_msg_data();
  inline void set_has_hash_ident();
  inline void clear_has_hash_ident();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::AFMsg::Ident* player_id_;
  ::std::string* msg_data_;
  ::google::protobuf::RepeatedPtrField< ::AFMsg::Ident > player_client_list_;
  ::AFMsg::Ident* hash_ident_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_AFMsgBase_2eproto();
  friend void protobuf_AssignDesc_AFMsgBase_2eproto();
  friend void protobuf_ShutdownFile_AFMsgBase_2eproto();

  void InitAsDefaultInstance();
  static MsgBase* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT Position : public ::google::protobuf::Message {
 public:
  Position();
  virtual ~Position();

  Position(const Position& from);

  inline Position& operator=(const Position& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Position& default_instance();

  void Swap(Position* other);

  // implements Message ----------------------------------------------

  Position* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Position& from);
  void MergeFrom(const Position& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline float x() const;
  inline void set_x(float value);

  // required float y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline float y() const;
  inline void set_y(float value);

  // required float z = 3;
  inline bool has_z() const;
  inline void clear_z();
  static const int kZFieldNumber = 3;
  inline float z() const;
  inline void set_z(float value);

  // @@protoc_insertion_point(class_scope:AFMsg.Position)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float x_;
  float y_;
  float z_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_AFMsgBase_2eproto();
  friend void protobuf_AssignDesc_AFMsgBase_2eproto();
  friend void protobuf_ShutdownFile_AFMsgBase_2eproto();

  void InitAsDefaultInstance();
  static Position* default_instance_;
};
// -------------------------------------------------------------------

class LIBPROTOC_EXPORT ReqCommand : public ::google::protobuf::Message {
 public:
  ReqCommand();
  virtual ~ReqCommand();

  ReqCommand(const ReqCommand& from);

  inline ReqCommand& operator=(const ReqCommand& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqCommand& default_instance();

  void Swap(ReqCommand* other);

  // implements Message ----------------------------------------------

  ReqCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqCommand& from);
  void MergeFrom(const ReqCommand& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ReqCommand_EGameCommandType EGameCommandType;
  static const EGameCommandType EGCT_MODIY_PROPERTY = ReqCommand_EGameCommandType_EGCT_MODIY_PROPERTY;
  static const EGameCommandType EGCT_MODIY_ITEM = ReqCommand_EGameCommandType_EGCT_MODIY_ITEM;
  static const EGameCommandType EGCT_CREATE_OBJECT = ReqCommand_EGameCommandType_EGCT_CREATE_OBJECT;
  static const EGameCommandType EGCT_ADD_ROLE_EXP = ReqCommand_EGameCommandType_EGCT_ADD_ROLE_EXP;
  static inline bool EGameCommandType_IsValid(int value) {
    return ReqCommand_EGameCommandType_IsValid(value);
  }
  static const EGameCommandType EGameCommandType_MIN =
    ReqCommand_EGameCommandType_EGameCommandType_MIN;
  static const EGameCommandType EGameCommandType_MAX =
    ReqCommand_EGameCommandType_EGameCommandType_MAX;
  static const int EGameCommandType_ARRAYSIZE =
    ReqCommand_EGameCommandType_EGameCommandType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EGameCommandType_descriptor() {
    return ReqCommand_EGameCommandType_descriptor();
  }
  static inline const ::std::string& EGameCommandType_Name(EGameCommandType value) {
    return ReqCommand_EGameCommandType_Name(value);
  }
  static inline bool EGameCommandType_Parse(const ::std::string& name,
      EGameCommandType* value) {
    return ReqCommand_EGameCommandType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .AFMsg.Ident control_id = 1;
  inline bool has_control_id() const;
  inline void clear_control_id();
  static const int kControlIdFieldNumber = 1;
  inline const ::AFMsg::Ident& control_id() const;
  inline ::AFMsg::Ident* mutable_control_id();
  inline ::AFMsg::Ident* release_control_id();
  inline void set_allocated_control_id(::AFMsg::Ident* control_id);

  // required .AFMsg.ReqCommand.EGameCommandType command_id = 2;
  inline bool has_command_id() const;
  inline void clear_command_id();
  static const int kCommandIdFieldNumber = 2;
  inline ::AFMsg::ReqCommand_EGameCommandType command_id() const;
  inline void set_command_id(::AFMsg::ReqCommand_EGameCommandType value);

  // optional bytes command_str_value = 3;
  inline bool has_command_str_value() const;
  inline void clear_command_str_value();
  static const int kCommandStrValueFieldNumber = 3;
  inline const ::std::string& command_str_value() const;
  inline void set_command_str_value(const ::std::string& value);
  inline void set_command_str_value(const char* value);
  inline void set_command_str_value(const void* value, size_t size);
  inline ::std::string* mutable_command_str_value();
  inline ::std::string* release_command_str_value();
  inline void set_allocated_command_str_value(::std::string* command_str_value);

  // optional int64 command_value_int = 4;
  inline bool has_command_value_int() const;
  inline void clear_command_value_int();
  static const int kCommandValueIntFieldNumber = 4;
  inline ::google::protobuf::int64 command_value_int() const;
  inline void set_command_value_int(::google::protobuf::int64 value);

  // optional float command_value_float = 5;
  inline bool has_command_value_float() const;
  inline void clear_command_value_float();
  static const int kCommandValueFloatFieldNumber = 5;
  inline float command_value_float() const;
  inline void set_command_value_float(float value);

  // optional bytes command_value_str = 6;
  inline bool has_command_value_str() const;
  inline void clear_command_value_str();
  static const int kCommandValueStrFieldNumber = 6;
  inline const ::std::string& command_value_str() const;
  inline void set_command_value_str(const ::std::string& value);
  inline void set_command_value_str(const char* value);
  inline void set_command_value_str(const void* value, size_t size);
  inline ::std::string* mutable_command_value_str();
  inline ::std::string* release_command_value_str();
  inline void set_allocated_command_value_str(::std::string* command_value_str);

  // optional .AFMsg.Ident command_value_object = 7;
  inline bool has_command_value_object() const;
  inline void clear_command_value_object();
  static const int kCommandValueObjectFieldNumber = 7;
  inline const ::AFMsg::Ident& command_value_object() const;
  inline ::AFMsg::Ident* mutable_command_value_object();
  inline ::AFMsg::Ident* release_command_value_object();
  inline void set_allocated_command_value_object(::AFMsg::Ident* command_value_object);

  // optional int32 row = 8;
  inline bool has_row() const;
  inline void clear_row();
  static const int kRowFieldNumber = 8;
  inline ::google::protobuf::int32 row() const;
  inline void set_row(::google::protobuf::int32 value);

  // optional int32 col = 9;
  inline bool has_col() const;
  inline void clear_col();
  static const int kColFieldNumber = 9;
  inline ::google::protobuf::int32 col() const;
  inline void set_col(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:AFMsg.ReqCommand)
 private:
  inline void set_has_control_id();
  inline void clear_has_control_id();
  inline void set_has_command_id();
  inline void clear_has_command_id();
  inline void set_has_command_str_value();
  inline void clear_has_command_str_value();
  inline void set_has_command_value_int();
  inline void clear_has_command_value_int();
  inline void set_has_command_value_float();
  inline void clear_has_command_value_float();
  inline void set_has_command_value_str();
  inline void clear_has_command_value_str();
  inline void set_has_command_value_object();
  inline void clear_has_command_value_object();
  inline void set_has_row();
  inline void clear_has_row();
  inline void set_has_col();
  inline void clear_has_col();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::AFMsg::Ident* control_id_;
  ::std::string* command_str_value_;
  int command_id_;
  float command_value_float_;
  ::google::protobuf::int64 command_value_int_;
  ::std::string* command_value_str_;
  ::AFMsg::Ident* command_value_object_;
  ::google::protobuf::int32 row_;
  ::google::protobuf::int32 col_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void LIBPROTOC_EXPORT protobuf_AddDesc_AFMsgBase_2eproto();
  friend void protobuf_AssignDesc_AFMsgBase_2eproto();
  friend void protobuf_ShutdownFile_AFMsgBase_2eproto();

  void InitAsDefaultInstance();
  static ReqCommand* default_instance_;
};
// ===================================================================


// ===================================================================

// Ident

// required int32 svrid = 1;
inline bool Ident::has_svrid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Ident::set_has_svrid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Ident::clear_has_svrid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Ident::clear_svrid() {
  svrid_ = 0;
  clear_has_svrid();
}
inline ::google::protobuf::int32 Ident::svrid() const {
  return svrid_;
}
inline void Ident::set_svrid(::google::protobuf::int32 value) {
  set_has_svrid();
  svrid_ = value;
}

// required int32 index = 2;
inline bool Ident::has_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Ident::set_has_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Ident::clear_has_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Ident::clear_index() {
  index_ = 0;
  clear_has_index();
}
inline ::google::protobuf::int32 Ident::index() const {
  return index_;
}
inline void Ident::set_index(::google::protobuf::int32 value) {
  set_has_index();
  index_ = value;
}

// -------------------------------------------------------------------

// Point3D

// required float x = 1;
inline bool Point3D::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Point3D::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Point3D::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Point3D::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float Point3D::x() const {
  return x_;
}
inline void Point3D::set_x(float value) {
  set_has_x();
  x_ = value;
}

// required float y = 2;
inline bool Point3D::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Point3D::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Point3D::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Point3D::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float Point3D::y() const {
  return y_;
}
inline void Point3D::set_y(float value) {
  set_has_y();
  y_ = value;
}

// required float z = 3;
inline bool Point3D::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Point3D::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Point3D::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Point3D::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline float Point3D::z() const {
  return z_;
}
inline void Point3D::set_z(float value) {
  set_has_z();
  z_ = value;
}

// -------------------------------------------------------------------

// PropertyPBData

// required bytes property_name = 1;
inline bool PropertyPBData::has_property_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PropertyPBData::set_has_property_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PropertyPBData::clear_has_property_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PropertyPBData::clear_property_name() {
  if (property_name_ != &::google::protobuf::internal::kEmptyString) {
    property_name_->clear();
  }
  clear_has_property_name();
}
inline const ::std::string& PropertyPBData::property_name() const {
  return *property_name_;
}
inline void PropertyPBData::set_property_name(const ::std::string& value) {
  set_has_property_name();
  if (property_name_ == &::google::protobuf::internal::kEmptyString) {
    property_name_ = new ::std::string;
  }
  property_name_->assign(value);
}
inline void PropertyPBData::set_property_name(const char* value) {
  set_has_property_name();
  if (property_name_ == &::google::protobuf::internal::kEmptyString) {
    property_name_ = new ::std::string;
  }
  property_name_->assign(value);
}
inline void PropertyPBData::set_property_name(const void* value, size_t size) {
  set_has_property_name();
  if (property_name_ == &::google::protobuf::internal::kEmptyString) {
    property_name_ = new ::std::string;
  }
  property_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PropertyPBData::mutable_property_name() {
  set_has_property_name();
  if (property_name_ == &::google::protobuf::internal::kEmptyString) {
    property_name_ = new ::std::string;
  }
  return property_name_;
}
inline ::std::string* PropertyPBData::release_property_name() {
  clear_has_property_name();
  if (property_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = property_name_;
    property_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PropertyPBData::set_allocated_property_name(::std::string* property_name) {
  if (property_name_ != &::google::protobuf::internal::kEmptyString) {
    delete property_name_;
  }
  if (property_name) {
    set_has_property_name();
    property_name_ = property_name;
  } else {
    clear_has_property_name();
    property_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 ndataType = 2;
inline bool PropertyPBData::has_ndatatype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PropertyPBData::set_has_ndatatype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PropertyPBData::clear_has_ndatatype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PropertyPBData::clear_ndatatype() {
  ndatatype_ = 0;
  clear_has_ndatatype();
}
inline ::google::protobuf::int32 PropertyPBData::ndatatype() const {
  return ndatatype_;
}
inline void PropertyPBData::set_ndatatype(::google::protobuf::int32 value) {
  set_has_ndatatype();
  ndatatype_ = value;
}

// optional bool mbValue = 3;
inline bool PropertyPBData::has_mbvalue() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PropertyPBData::set_has_mbvalue() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PropertyPBData::clear_has_mbvalue() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PropertyPBData::clear_mbvalue() {
  mbvalue_ = false;
  clear_has_mbvalue();
}
inline bool PropertyPBData::mbvalue() const {
  return mbvalue_;
}
inline void PropertyPBData::set_mbvalue(bool value) {
  set_has_mbvalue();
  mbvalue_ = value;
}

// optional int32 mnValue = 4;
inline bool PropertyPBData::has_mnvalue() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PropertyPBData::set_has_mnvalue() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PropertyPBData::clear_has_mnvalue() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PropertyPBData::clear_mnvalue() {
  mnvalue_ = 0;
  clear_has_mnvalue();
}
inline ::google::protobuf::int32 PropertyPBData::mnvalue() const {
  return mnvalue_;
}
inline void PropertyPBData::set_mnvalue(::google::protobuf::int32 value) {
  set_has_mnvalue();
  mnvalue_ = value;
}

// optional int64 mn64Value = 5;
inline bool PropertyPBData::has_mn64value() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PropertyPBData::set_has_mn64value() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PropertyPBData::clear_has_mn64value() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PropertyPBData::clear_mn64value() {
  mn64value_ = GOOGLE_LONGLONG(0);
  clear_has_mn64value();
}
inline ::google::protobuf::int64 PropertyPBData::mn64value() const {
  return mn64value_;
}
inline void PropertyPBData::set_mn64value(::google::protobuf::int64 value) {
  set_has_mn64value();
  mn64value_ = value;
}

// optional float mfValue = 6;
inline bool PropertyPBData::has_mfvalue() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PropertyPBData::set_has_mfvalue() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PropertyPBData::clear_has_mfvalue() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PropertyPBData::clear_mfvalue() {
  mfvalue_ = 0;
  clear_has_mfvalue();
}
inline float PropertyPBData::mfvalue() const {
  return mfvalue_;
}
inline void PropertyPBData::set_mfvalue(float value) {
  set_has_mfvalue();
  mfvalue_ = value;
}

// optional double mdValue = 7;
inline bool PropertyPBData::has_mdvalue() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PropertyPBData::set_has_mdvalue() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PropertyPBData::clear_has_mdvalue() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PropertyPBData::clear_mdvalue() {
  mdvalue_ = 0;
  clear_has_mdvalue();
}
inline double PropertyPBData::mdvalue() const {
  return mdvalue_;
}
inline void PropertyPBData::set_mdvalue(double value) {
  set_has_mdvalue();
  mdvalue_ = value;
}

// optional bytes mstrValue = 8;
inline bool PropertyPBData::has_mstrvalue() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PropertyPBData::set_has_mstrvalue() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PropertyPBData::clear_has_mstrvalue() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PropertyPBData::clear_mstrvalue() {
  if (mstrvalue_ != &::google::protobuf::internal::kEmptyString) {
    mstrvalue_->clear();
  }
  clear_has_mstrvalue();
}
inline const ::std::string& PropertyPBData::mstrvalue() const {
  return *mstrvalue_;
}
inline void PropertyPBData::set_mstrvalue(const ::std::string& value) {
  set_has_mstrvalue();
  if (mstrvalue_ == &::google::protobuf::internal::kEmptyString) {
    mstrvalue_ = new ::std::string;
  }
  mstrvalue_->assign(value);
}
inline void PropertyPBData::set_mstrvalue(const char* value) {
  set_has_mstrvalue();
  if (mstrvalue_ == &::google::protobuf::internal::kEmptyString) {
    mstrvalue_ = new ::std::string;
  }
  mstrvalue_->assign(value);
}
inline void PropertyPBData::set_mstrvalue(const void* value, size_t size) {
  set_has_mstrvalue();
  if (mstrvalue_ == &::google::protobuf::internal::kEmptyString) {
    mstrvalue_ = new ::std::string;
  }
  mstrvalue_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PropertyPBData::mutable_mstrvalue() {
  set_has_mstrvalue();
  if (mstrvalue_ == &::google::protobuf::internal::kEmptyString) {
    mstrvalue_ = new ::std::string;
  }
  return mstrvalue_;
}
inline ::std::string* PropertyPBData::release_mstrvalue() {
  clear_has_mstrvalue();
  if (mstrvalue_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mstrvalue_;
    mstrvalue_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PropertyPBData::set_allocated_mstrvalue(::std::string* mstrvalue) {
  if (mstrvalue_ != &::google::protobuf::internal::kEmptyString) {
    delete mstrvalue_;
  }
  if (mstrvalue) {
    set_has_mstrvalue();
    mstrvalue_ = mstrvalue;
  } else {
    clear_has_mstrvalue();
    mstrvalue_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 mpVaule = 9;
inline bool PropertyPBData::has_mpvaule() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PropertyPBData::set_has_mpvaule() {
  _has_bits_[0] |= 0x00000100u;
}
inline void PropertyPBData::clear_has_mpvaule() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void PropertyPBData::clear_mpvaule() {
  mpvaule_ = GOOGLE_LONGLONG(0);
  clear_has_mpvaule();
}
inline ::google::protobuf::int64 PropertyPBData::mpvaule() const {
  return mpvaule_;
}
inline void PropertyPBData::set_mpvaule(::google::protobuf::int64 value) {
  set_has_mpvaule();
  mpvaule_ = value;
}

// optional bytes mpUserData = 10;
inline bool PropertyPBData::has_mpuserdata() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void PropertyPBData::set_has_mpuserdata() {
  _has_bits_[0] |= 0x00000200u;
}
inline void PropertyPBData::clear_has_mpuserdata() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void PropertyPBData::clear_mpuserdata() {
  if (mpuserdata_ != &::google::protobuf::internal::kEmptyString) {
    mpuserdata_->clear();
  }
  clear_has_mpuserdata();
}
inline const ::std::string& PropertyPBData::mpuserdata() const {
  return *mpuserdata_;
}
inline void PropertyPBData::set_mpuserdata(const ::std::string& value) {
  set_has_mpuserdata();
  if (mpuserdata_ == &::google::protobuf::internal::kEmptyString) {
    mpuserdata_ = new ::std::string;
  }
  mpuserdata_->assign(value);
}
inline void PropertyPBData::set_mpuserdata(const char* value) {
  set_has_mpuserdata();
  if (mpuserdata_ == &::google::protobuf::internal::kEmptyString) {
    mpuserdata_ = new ::std::string;
  }
  mpuserdata_->assign(value);
}
inline void PropertyPBData::set_mpuserdata(const void* value, size_t size) {
  set_has_mpuserdata();
  if (mpuserdata_ == &::google::protobuf::internal::kEmptyString) {
    mpuserdata_ = new ::std::string;
  }
  mpuserdata_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PropertyPBData::mutable_mpuserdata() {
  set_has_mpuserdata();
  if (mpuserdata_ == &::google::protobuf::internal::kEmptyString) {
    mpuserdata_ = new ::std::string;
  }
  return mpuserdata_;
}
inline ::std::string* PropertyPBData::release_mpuserdata() {
  clear_has_mpuserdata();
  if (mpuserdata_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mpuserdata_;
    mpuserdata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PropertyPBData::set_allocated_mpuserdata(::std::string* mpuserdata) {
  if (mpuserdata_ != &::google::protobuf::internal::kEmptyString) {
    delete mpuserdata_;
  }
  if (mpuserdata) {
    set_has_mpuserdata();
    mpuserdata_ = mpuserdata;
  } else {
    clear_has_mpuserdata();
    mpuserdata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .AFMsg.Ident mGuid = 11;
inline bool PropertyPBData::has_mguid() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void PropertyPBData::set_has_mguid() {
  _has_bits_[0] |= 0x00000400u;
}
inline void PropertyPBData::clear_has_mguid() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void PropertyPBData::clear_mguid() {
  if (mguid_ != NULL) mguid_->::AFMsg::Ident::Clear();
  clear_has_mguid();
}
inline const ::AFMsg::Ident& PropertyPBData::mguid() const {
  return mguid_ != NULL ? *mguid_ : *default_instance_->mguid_;
}
inline ::AFMsg::Ident* PropertyPBData::mutable_mguid() {
  set_has_mguid();
  if (mguid_ == NULL) mguid_ = new ::AFMsg::Ident;
  return mguid_;
}
inline ::AFMsg::Ident* PropertyPBData::release_mguid() {
  clear_has_mguid();
  ::AFMsg::Ident* temp = mguid_;
  mguid_ = NULL;
  return temp;
}
inline void PropertyPBData::set_allocated_mguid(::AFMsg::Ident* mguid) {
  delete mguid_;
  mguid_ = mguid;
  if (mguid) {
    set_has_mguid();
  } else {
    clear_has_mguid();
  }
}

// -------------------------------------------------------------------

// RecordPBData

// required int32 row = 1;
inline bool RecordPBData::has_row() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RecordPBData::set_has_row() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RecordPBData::clear_has_row() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RecordPBData::clear_row() {
  row_ = 0;
  clear_has_row();
}
inline ::google::protobuf::int32 RecordPBData::row() const {
  return row_;
}
inline void RecordPBData::set_row(::google::protobuf::int32 value) {
  set_has_row();
  row_ = value;
}

// required int32 col = 2;
inline bool RecordPBData::has_col() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RecordPBData::set_has_col() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RecordPBData::clear_has_col() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RecordPBData::clear_col() {
  col_ = 0;
  clear_has_col();
}
inline ::google::protobuf::int32 RecordPBData::col() const {
  return col_;
}
inline void RecordPBData::set_col(::google::protobuf::int32 value) {
  set_has_col();
  col_ = value;
}

// required int32 ndataType = 3;
inline bool RecordPBData::has_ndatatype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RecordPBData::set_has_ndatatype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RecordPBData::clear_has_ndatatype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RecordPBData::clear_ndatatype() {
  ndatatype_ = 0;
  clear_has_ndatatype();
}
inline ::google::protobuf::int32 RecordPBData::ndatatype() const {
  return ndatatype_;
}
inline void RecordPBData::set_ndatatype(::google::protobuf::int32 value) {
  set_has_ndatatype();
  ndatatype_ = value;
}

// optional bool mbValue = 4;
inline bool RecordPBData::has_mbvalue() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RecordPBData::set_has_mbvalue() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RecordPBData::clear_has_mbvalue() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RecordPBData::clear_mbvalue() {
  mbvalue_ = false;
  clear_has_mbvalue();
}
inline bool RecordPBData::mbvalue() const {
  return mbvalue_;
}
inline void RecordPBData::set_mbvalue(bool value) {
  set_has_mbvalue();
  mbvalue_ = value;
}

// optional int32 mnValue = 5;
inline bool RecordPBData::has_mnvalue() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RecordPBData::set_has_mnvalue() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RecordPBData::clear_has_mnvalue() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RecordPBData::clear_mnvalue() {
  mnvalue_ = 0;
  clear_has_mnvalue();
}
inline ::google::protobuf::int32 RecordPBData::mnvalue() const {
  return mnvalue_;
}
inline void RecordPBData::set_mnvalue(::google::protobuf::int32 value) {
  set_has_mnvalue();
  mnvalue_ = value;
}

// optional int64 mn64Value = 6;
inline bool RecordPBData::has_mn64value() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RecordPBData::set_has_mn64value() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RecordPBData::clear_has_mn64value() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RecordPBData::clear_mn64value() {
  mn64value_ = GOOGLE_LONGLONG(0);
  clear_has_mn64value();
}
inline ::google::protobuf::int64 RecordPBData::mn64value() const {
  return mn64value_;
}
inline void RecordPBData::set_mn64value(::google::protobuf::int64 value) {
  set_has_mn64value();
  mn64value_ = value;
}

// optional float mfValue = 7;
inline bool RecordPBData::has_mfvalue() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RecordPBData::set_has_mfvalue() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RecordPBData::clear_has_mfvalue() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RecordPBData::clear_mfvalue() {
  mfvalue_ = 0;
  clear_has_mfvalue();
}
inline float RecordPBData::mfvalue() const {
  return mfvalue_;
}
inline void RecordPBData::set_mfvalue(float value) {
  set_has_mfvalue();
  mfvalue_ = value;
}

// optional double mdValue = 8;
inline bool RecordPBData::has_mdvalue() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RecordPBData::set_has_mdvalue() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RecordPBData::clear_has_mdvalue() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RecordPBData::clear_mdvalue() {
  mdvalue_ = 0;
  clear_has_mdvalue();
}
inline double RecordPBData::mdvalue() const {
  return mdvalue_;
}
inline void RecordPBData::set_mdvalue(double value) {
  set_has_mdvalue();
  mdvalue_ = value;
}

// optional bytes mstrValue = 9;
inline bool RecordPBData::has_mstrvalue() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RecordPBData::set_has_mstrvalue() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RecordPBData::clear_has_mstrvalue() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RecordPBData::clear_mstrvalue() {
  if (mstrvalue_ != &::google::protobuf::internal::kEmptyString) {
    mstrvalue_->clear();
  }
  clear_has_mstrvalue();
}
inline const ::std::string& RecordPBData::mstrvalue() const {
  return *mstrvalue_;
}
inline void RecordPBData::set_mstrvalue(const ::std::string& value) {
  set_has_mstrvalue();
  if (mstrvalue_ == &::google::protobuf::internal::kEmptyString) {
    mstrvalue_ = new ::std::string;
  }
  mstrvalue_->assign(value);
}
inline void RecordPBData::set_mstrvalue(const char* value) {
  set_has_mstrvalue();
  if (mstrvalue_ == &::google::protobuf::internal::kEmptyString) {
    mstrvalue_ = new ::std::string;
  }
  mstrvalue_->assign(value);
}
inline void RecordPBData::set_mstrvalue(const void* value, size_t size) {
  set_has_mstrvalue();
  if (mstrvalue_ == &::google::protobuf::internal::kEmptyString) {
    mstrvalue_ = new ::std::string;
  }
  mstrvalue_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RecordPBData::mutable_mstrvalue() {
  set_has_mstrvalue();
  if (mstrvalue_ == &::google::protobuf::internal::kEmptyString) {
    mstrvalue_ = new ::std::string;
  }
  return mstrvalue_;
}
inline ::std::string* RecordPBData::release_mstrvalue() {
  clear_has_mstrvalue();
  if (mstrvalue_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mstrvalue_;
    mstrvalue_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RecordPBData::set_allocated_mstrvalue(::std::string* mstrvalue) {
  if (mstrvalue_ != &::google::protobuf::internal::kEmptyString) {
    delete mstrvalue_;
  }
  if (mstrvalue) {
    set_has_mstrvalue();
    mstrvalue_ = mstrvalue;
  } else {
    clear_has_mstrvalue();
    mstrvalue_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 mpVaule = 10;
inline bool RecordPBData::has_mpvaule() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void RecordPBData::set_has_mpvaule() {
  _has_bits_[0] |= 0x00000200u;
}
inline void RecordPBData::clear_has_mpvaule() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void RecordPBData::clear_mpvaule() {
  mpvaule_ = GOOGLE_LONGLONG(0);
  clear_has_mpvaule();
}
inline ::google::protobuf::int64 RecordPBData::mpvaule() const {
  return mpvaule_;
}
inline void RecordPBData::set_mpvaule(::google::protobuf::int64 value) {
  set_has_mpvaule();
  mpvaule_ = value;
}

// optional bytes mpUserData = 11;
inline bool RecordPBData::has_mpuserdata() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void RecordPBData::set_has_mpuserdata() {
  _has_bits_[0] |= 0x00000400u;
}
inline void RecordPBData::clear_has_mpuserdata() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void RecordPBData::clear_mpuserdata() {
  if (mpuserdata_ != &::google::protobuf::internal::kEmptyString) {
    mpuserdata_->clear();
  }
  clear_has_mpuserdata();
}
inline const ::std::string& RecordPBData::mpuserdata() const {
  return *mpuserdata_;
}
inline void RecordPBData::set_mpuserdata(const ::std::string& value) {
  set_has_mpuserdata();
  if (mpuserdata_ == &::google::protobuf::internal::kEmptyString) {
    mpuserdata_ = new ::std::string;
  }
  mpuserdata_->assign(value);
}
inline void RecordPBData::set_mpuserdata(const char* value) {
  set_has_mpuserdata();
  if (mpuserdata_ == &::google::protobuf::internal::kEmptyString) {
    mpuserdata_ = new ::std::string;
  }
  mpuserdata_->assign(value);
}
inline void RecordPBData::set_mpuserdata(const void* value, size_t size) {
  set_has_mpuserdata();
  if (mpuserdata_ == &::google::protobuf::internal::kEmptyString) {
    mpuserdata_ = new ::std::string;
  }
  mpuserdata_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RecordPBData::mutable_mpuserdata() {
  set_has_mpuserdata();
  if (mpuserdata_ == &::google::protobuf::internal::kEmptyString) {
    mpuserdata_ = new ::std::string;
  }
  return mpuserdata_;
}
inline ::std::string* RecordPBData::release_mpuserdata() {
  clear_has_mpuserdata();
  if (mpuserdata_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mpuserdata_;
    mpuserdata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RecordPBData::set_allocated_mpuserdata(::std::string* mpuserdata) {
  if (mpuserdata_ != &::google::protobuf::internal::kEmptyString) {
    delete mpuserdata_;
  }
  if (mpuserdata) {
    set_has_mpuserdata();
    mpuserdata_ = mpuserdata;
  } else {
    clear_has_mpuserdata();
    mpuserdata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .AFMsg.Ident mGuid = 12;
inline bool RecordPBData::has_mguid() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void RecordPBData::set_has_mguid() {
  _has_bits_[0] |= 0x00000800u;
}
inline void RecordPBData::clear_has_mguid() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void RecordPBData::clear_mguid() {
  if (mguid_ != NULL) mguid_->::AFMsg::Ident::Clear();
  clear_has_mguid();
}
inline const ::AFMsg::Ident& RecordPBData::mguid() const {
  return mguid_ != NULL ? *mguid_ : *default_instance_->mguid_;
}
inline ::AFMsg::Ident* RecordPBData::mutable_mguid() {
  set_has_mguid();
  if (mguid_ == NULL) mguid_ = new ::AFMsg::Ident;
  return mguid_;
}
inline ::AFMsg::Ident* RecordPBData::release_mguid() {
  clear_has_mguid();
  ::AFMsg::Ident* temp = mguid_;
  mguid_ = NULL;
  return temp;
}
inline void RecordPBData::set_allocated_mguid(::AFMsg::Ident* mguid) {
  delete mguid_;
  mguid_ = mguid;
  if (mguid) {
    set_has_mguid();
  } else {
    clear_has_mguid();
  }
}

// -------------------------------------------------------------------

// PBData

// required int32 ndataType = 1;
inline bool PBData::has_ndatatype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PBData::set_has_ndatatype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PBData::clear_has_ndatatype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PBData::clear_ndatatype() {
  ndatatype_ = 0;
  clear_has_ndatatype();
}
inline ::google::protobuf::int32 PBData::ndatatype() const {
  return ndatatype_;
}
inline void PBData::set_ndatatype(::google::protobuf::int32 value) {
  set_has_ndatatype();
  ndatatype_ = value;
}

// optional bool mbValue = 2;
inline bool PBData::has_mbvalue() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PBData::set_has_mbvalue() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PBData::clear_has_mbvalue() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PBData::clear_mbvalue() {
  mbvalue_ = false;
  clear_has_mbvalue();
}
inline bool PBData::mbvalue() const {
  return mbvalue_;
}
inline void PBData::set_mbvalue(bool value) {
  set_has_mbvalue();
  mbvalue_ = value;
}

// optional int32 mnValue = 3;
inline bool PBData::has_mnvalue() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PBData::set_has_mnvalue() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PBData::clear_has_mnvalue() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PBData::clear_mnvalue() {
  mnvalue_ = 0;
  clear_has_mnvalue();
}
inline ::google::protobuf::int32 PBData::mnvalue() const {
  return mnvalue_;
}
inline void PBData::set_mnvalue(::google::protobuf::int32 value) {
  set_has_mnvalue();
  mnvalue_ = value;
}

// optional int64 mn64Value = 4;
inline bool PBData::has_mn64value() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PBData::set_has_mn64value() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PBData::clear_has_mn64value() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PBData::clear_mn64value() {
  mn64value_ = GOOGLE_LONGLONG(0);
  clear_has_mn64value();
}
inline ::google::protobuf::int64 PBData::mn64value() const {
  return mn64value_;
}
inline void PBData::set_mn64value(::google::protobuf::int64 value) {
  set_has_mn64value();
  mn64value_ = value;
}

// optional float mfValue = 5;
inline bool PBData::has_mfvalue() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PBData::set_has_mfvalue() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PBData::clear_has_mfvalue() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PBData::clear_mfvalue() {
  mfvalue_ = 0;
  clear_has_mfvalue();
}
inline float PBData::mfvalue() const {
  return mfvalue_;
}
inline void PBData::set_mfvalue(float value) {
  set_has_mfvalue();
  mfvalue_ = value;
}

// optional double mdValue = 6;
inline bool PBData::has_mdvalue() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PBData::set_has_mdvalue() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PBData::clear_has_mdvalue() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PBData::clear_mdvalue() {
  mdvalue_ = 0;
  clear_has_mdvalue();
}
inline double PBData::mdvalue() const {
  return mdvalue_;
}
inline void PBData::set_mdvalue(double value) {
  set_has_mdvalue();
  mdvalue_ = value;
}

// optional bytes mstrValue = 7;
inline bool PBData::has_mstrvalue() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PBData::set_has_mstrvalue() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PBData::clear_has_mstrvalue() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PBData::clear_mstrvalue() {
  if (mstrvalue_ != &::google::protobuf::internal::kEmptyString) {
    mstrvalue_->clear();
  }
  clear_has_mstrvalue();
}
inline const ::std::string& PBData::mstrvalue() const {
  return *mstrvalue_;
}
inline void PBData::set_mstrvalue(const ::std::string& value) {
  set_has_mstrvalue();
  if (mstrvalue_ == &::google::protobuf::internal::kEmptyString) {
    mstrvalue_ = new ::std::string;
  }
  mstrvalue_->assign(value);
}
inline void PBData::set_mstrvalue(const char* value) {
  set_has_mstrvalue();
  if (mstrvalue_ == &::google::protobuf::internal::kEmptyString) {
    mstrvalue_ = new ::std::string;
  }
  mstrvalue_->assign(value);
}
inline void PBData::set_mstrvalue(const void* value, size_t size) {
  set_has_mstrvalue();
  if (mstrvalue_ == &::google::protobuf::internal::kEmptyString) {
    mstrvalue_ = new ::std::string;
  }
  mstrvalue_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PBData::mutable_mstrvalue() {
  set_has_mstrvalue();
  if (mstrvalue_ == &::google::protobuf::internal::kEmptyString) {
    mstrvalue_ = new ::std::string;
  }
  return mstrvalue_;
}
inline ::std::string* PBData::release_mstrvalue() {
  clear_has_mstrvalue();
  if (mstrvalue_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mstrvalue_;
    mstrvalue_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PBData::set_allocated_mstrvalue(::std::string* mstrvalue) {
  if (mstrvalue_ != &::google::protobuf::internal::kEmptyString) {
    delete mstrvalue_;
  }
  if (mstrvalue) {
    set_has_mstrvalue();
    mstrvalue_ = mstrvalue;
  } else {
    clear_has_mstrvalue();
    mstrvalue_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 mpVaule = 8;
inline bool PBData::has_mpvaule() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PBData::set_has_mpvaule() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PBData::clear_has_mpvaule() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PBData::clear_mpvaule() {
  mpvaule_ = GOOGLE_LONGLONG(0);
  clear_has_mpvaule();
}
inline ::google::protobuf::int64 PBData::mpvaule() const {
  return mpvaule_;
}
inline void PBData::set_mpvaule(::google::protobuf::int64 value) {
  set_has_mpvaule();
  mpvaule_ = value;
}

// optional bytes mpUserData = 9;
inline bool PBData::has_mpuserdata() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PBData::set_has_mpuserdata() {
  _has_bits_[0] |= 0x00000100u;
}
inline void PBData::clear_has_mpuserdata() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void PBData::clear_mpuserdata() {
  if (mpuserdata_ != &::google::protobuf::internal::kEmptyString) {
    mpuserdata_->clear();
  }
  clear_has_mpuserdata();
}
inline const ::std::string& PBData::mpuserdata() const {
  return *mpuserdata_;
}
inline void PBData::set_mpuserdata(const ::std::string& value) {
  set_has_mpuserdata();
  if (mpuserdata_ == &::google::protobuf::internal::kEmptyString) {
    mpuserdata_ = new ::std::string;
  }
  mpuserdata_->assign(value);
}
inline void PBData::set_mpuserdata(const char* value) {
  set_has_mpuserdata();
  if (mpuserdata_ == &::google::protobuf::internal::kEmptyString) {
    mpuserdata_ = new ::std::string;
  }
  mpuserdata_->assign(value);
}
inline void PBData::set_mpuserdata(const void* value, size_t size) {
  set_has_mpuserdata();
  if (mpuserdata_ == &::google::protobuf::internal::kEmptyString) {
    mpuserdata_ = new ::std::string;
  }
  mpuserdata_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PBData::mutable_mpuserdata() {
  set_has_mpuserdata();
  if (mpuserdata_ == &::google::protobuf::internal::kEmptyString) {
    mpuserdata_ = new ::std::string;
  }
  return mpuserdata_;
}
inline ::std::string* PBData::release_mpuserdata() {
  clear_has_mpuserdata();
  if (mpuserdata_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mpuserdata_;
    mpuserdata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PBData::set_allocated_mpuserdata(::std::string* mpuserdata) {
  if (mpuserdata_ != &::google::protobuf::internal::kEmptyString) {
    delete mpuserdata_;
  }
  if (mpuserdata) {
    set_has_mpuserdata();
    mpuserdata_ = mpuserdata;
  } else {
    clear_has_mpuserdata();
    mpuserdata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .AFMsg.Ident mGuid = 10;
inline bool PBData::has_mguid() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void PBData::set_has_mguid() {
  _has_bits_[0] |= 0x00000200u;
}
inline void PBData::clear_has_mguid() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void PBData::clear_mguid() {
  if (mguid_ != NULL) mguid_->::AFMsg::Ident::Clear();
  clear_has_mguid();
}
inline const ::AFMsg::Ident& PBData::mguid() const {
  return mguid_ != NULL ? *mguid_ : *default_instance_->mguid_;
}
inline ::AFMsg::Ident* PBData::mutable_mguid() {
  set_has_mguid();
  if (mguid_ == NULL) mguid_ = new ::AFMsg::Ident;
  return mguid_;
}
inline ::AFMsg::Ident* PBData::release_mguid() {
  clear_has_mguid();
  ::AFMsg::Ident* temp = mguid_;
  mguid_ = NULL;
  return temp;
}
inline void PBData::set_allocated_mguid(::AFMsg::Ident* mguid) {
  delete mguid_;
  mguid_ = mguid;
  if (mguid) {
    set_has_mguid();
  } else {
    clear_has_mguid();
  }
}

// -------------------------------------------------------------------

// DataListPBData

// repeated .AFMsg.PBData data_list = 1;
inline int DataListPBData::data_list_size() const {
  return data_list_.size();
}
inline void DataListPBData::clear_data_list() {
  data_list_.Clear();
}
inline const ::AFMsg::PBData& DataListPBData::data_list(int index) const {
  return data_list_.Get(index);
}
inline ::AFMsg::PBData* DataListPBData::mutable_data_list(int index) {
  return data_list_.Mutable(index);
}
inline ::AFMsg::PBData* DataListPBData::add_data_list() {
  return data_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::AFMsg::PBData >&
DataListPBData::data_list() const {
  return data_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::AFMsg::PBData >*
DataListPBData::mutable_data_list() {
  return &data_list_;
}

// -------------------------------------------------------------------

// RecordAddRowStruct

// required int32 row = 1;
inline bool RecordAddRowStruct::has_row() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RecordAddRowStruct::set_has_row() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RecordAddRowStruct::clear_has_row() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RecordAddRowStruct::clear_row() {
  row_ = 0;
  clear_has_row();
}
inline ::google::protobuf::int32 RecordAddRowStruct::row() const {
  return row_;
}
inline void RecordAddRowStruct::set_row(::google::protobuf::int32 value) {
  set_has_row();
  row_ = value;
}

// repeated .AFMsg.RecordPBData record_data_list = 2;
inline int RecordAddRowStruct::record_data_list_size() const {
  return record_data_list_.size();
}
inline void RecordAddRowStruct::clear_record_data_list() {
  record_data_list_.Clear();
}
inline const ::AFMsg::RecordPBData& RecordAddRowStruct::record_data_list(int index) const {
  return record_data_list_.Get(index);
}
inline ::AFMsg::RecordPBData* RecordAddRowStruct::mutable_record_data_list(int index) {
  return record_data_list_.Mutable(index);
}
inline ::AFMsg::RecordPBData* RecordAddRowStruct::add_record_data_list() {
  return record_data_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::AFMsg::RecordPBData >&
RecordAddRowStruct::record_data_list() const {
  return record_data_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::AFMsg::RecordPBData >*
RecordAddRowStruct::mutable_record_data_list() {
  return &record_data_list_;
}

// -------------------------------------------------------------------

// ObjectRecordBase

// required bytes record_name = 1;
inline bool ObjectRecordBase::has_record_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ObjectRecordBase::set_has_record_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ObjectRecordBase::clear_has_record_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ObjectRecordBase::clear_record_name() {
  if (record_name_ != &::google::protobuf::internal::kEmptyString) {
    record_name_->clear();
  }
  clear_has_record_name();
}
inline const ::std::string& ObjectRecordBase::record_name() const {
  return *record_name_;
}
inline void ObjectRecordBase::set_record_name(const ::std::string& value) {
  set_has_record_name();
  if (record_name_ == &::google::protobuf::internal::kEmptyString) {
    record_name_ = new ::std::string;
  }
  record_name_->assign(value);
}
inline void ObjectRecordBase::set_record_name(const char* value) {
  set_has_record_name();
  if (record_name_ == &::google::protobuf::internal::kEmptyString) {
    record_name_ = new ::std::string;
  }
  record_name_->assign(value);
}
inline void ObjectRecordBase::set_record_name(const void* value, size_t size) {
  set_has_record_name();
  if (record_name_ == &::google::protobuf::internal::kEmptyString) {
    record_name_ = new ::std::string;
  }
  record_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ObjectRecordBase::mutable_record_name() {
  set_has_record_name();
  if (record_name_ == &::google::protobuf::internal::kEmptyString) {
    record_name_ = new ::std::string;
  }
  return record_name_;
}
inline ::std::string* ObjectRecordBase::release_record_name() {
  clear_has_record_name();
  if (record_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = record_name_;
    record_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ObjectRecordBase::set_allocated_record_name(::std::string* record_name) {
  if (record_name_ != &::google::protobuf::internal::kEmptyString) {
    delete record_name_;
  }
  if (record_name) {
    set_has_record_name();
    record_name_ = record_name;
  } else {
    clear_has_record_name();
    record_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .AFMsg.RecordAddRowStruct row_struct = 2;
inline int ObjectRecordBase::row_struct_size() const {
  return row_struct_.size();
}
inline void ObjectRecordBase::clear_row_struct() {
  row_struct_.Clear();
}
inline const ::AFMsg::RecordAddRowStruct& ObjectRecordBase::row_struct(int index) const {
  return row_struct_.Get(index);
}
inline ::AFMsg::RecordAddRowStruct* ObjectRecordBase::mutable_row_struct(int index) {
  return row_struct_.Mutable(index);
}
inline ::AFMsg::RecordAddRowStruct* ObjectRecordBase::add_row_struct() {
  return row_struct_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::AFMsg::RecordAddRowStruct >&
ObjectRecordBase::row_struct() const {
  return row_struct_;
}
inline ::google::protobuf::RepeatedPtrField< ::AFMsg::RecordAddRowStruct >*
ObjectRecordBase::mutable_row_struct() {
  return &row_struct_;
}

// -------------------------------------------------------------------

// ObjectPropertyList

// required .AFMsg.Ident player_id = 1;
inline bool ObjectPropertyList::has_player_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ObjectPropertyList::set_has_player_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ObjectPropertyList::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ObjectPropertyList::clear_player_id() {
  if (player_id_ != NULL) player_id_->::AFMsg::Ident::Clear();
  clear_has_player_id();
}
inline const ::AFMsg::Ident& ObjectPropertyList::player_id() const {
  return player_id_ != NULL ? *player_id_ : *default_instance_->player_id_;
}
inline ::AFMsg::Ident* ObjectPropertyList::mutable_player_id() {
  set_has_player_id();
  if (player_id_ == NULL) player_id_ = new ::AFMsg::Ident;
  return player_id_;
}
inline ::AFMsg::Ident* ObjectPropertyList::release_player_id() {
  clear_has_player_id();
  ::AFMsg::Ident* temp = player_id_;
  player_id_ = NULL;
  return temp;
}
inline void ObjectPropertyList::set_allocated_player_id(::AFMsg::Ident* player_id) {
  delete player_id_;
  player_id_ = player_id;
  if (player_id) {
    set_has_player_id();
  } else {
    clear_has_player_id();
  }
}

// repeated .AFMsg.PropertyPBData property_data_list = 2;
inline int ObjectPropertyList::property_data_list_size() const {
  return property_data_list_.size();
}
inline void ObjectPropertyList::clear_property_data_list() {
  property_data_list_.Clear();
}
inline const ::AFMsg::PropertyPBData& ObjectPropertyList::property_data_list(int index) const {
  return property_data_list_.Get(index);
}
inline ::AFMsg::PropertyPBData* ObjectPropertyList::mutable_property_data_list(int index) {
  return property_data_list_.Mutable(index);
}
inline ::AFMsg::PropertyPBData* ObjectPropertyList::add_property_data_list() {
  return property_data_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::AFMsg::PropertyPBData >&
ObjectPropertyList::property_data_list() const {
  return property_data_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::AFMsg::PropertyPBData >*
ObjectPropertyList::mutable_property_data_list() {
  return &property_data_list_;
}

// -------------------------------------------------------------------

// MultiObjectPropertyList

// repeated .AFMsg.ObjectPropertyList multi_player_property = 1;
inline int MultiObjectPropertyList::multi_player_property_size() const {
  return multi_player_property_.size();
}
inline void MultiObjectPropertyList::clear_multi_player_property() {
  multi_player_property_.Clear();
}
inline const ::AFMsg::ObjectPropertyList& MultiObjectPropertyList::multi_player_property(int index) const {
  return multi_player_property_.Get(index);
}
inline ::AFMsg::ObjectPropertyList* MultiObjectPropertyList::mutable_multi_player_property(int index) {
  return multi_player_property_.Mutable(index);
}
inline ::AFMsg::ObjectPropertyList* MultiObjectPropertyList::add_multi_player_property() {
  return multi_player_property_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::AFMsg::ObjectPropertyList >&
MultiObjectPropertyList::multi_player_property() const {
  return multi_player_property_;
}
inline ::google::protobuf::RepeatedPtrField< ::AFMsg::ObjectPropertyList >*
MultiObjectPropertyList::mutable_multi_player_property() {
  return &multi_player_property_;
}

// -------------------------------------------------------------------

// ObjectRecordList

// required .AFMsg.Ident player_id = 1;
inline bool ObjectRecordList::has_player_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ObjectRecordList::set_has_player_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ObjectRecordList::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ObjectRecordList::clear_player_id() {
  if (player_id_ != NULL) player_id_->::AFMsg::Ident::Clear();
  clear_has_player_id();
}
inline const ::AFMsg::Ident& ObjectRecordList::player_id() const {
  return player_id_ != NULL ? *player_id_ : *default_instance_->player_id_;
}
inline ::AFMsg::Ident* ObjectRecordList::mutable_player_id() {
  set_has_player_id();
  if (player_id_ == NULL) player_id_ = new ::AFMsg::Ident;
  return player_id_;
}
inline ::AFMsg::Ident* ObjectRecordList::release_player_id() {
  clear_has_player_id();
  ::AFMsg::Ident* temp = player_id_;
  player_id_ = NULL;
  return temp;
}
inline void ObjectRecordList::set_allocated_player_id(::AFMsg::Ident* player_id) {
  delete player_id_;
  player_id_ = player_id;
  if (player_id) {
    set_has_player_id();
  } else {
    clear_has_player_id();
  }
}

// repeated .AFMsg.ObjectRecordBase record_list = 2;
inline int ObjectRecordList::record_list_size() const {
  return record_list_.size();
}
inline void ObjectRecordList::clear_record_list() {
  record_list_.Clear();
}
inline const ::AFMsg::ObjectRecordBase& ObjectRecordList::record_list(int index) const {
  return record_list_.Get(index);
}
inline ::AFMsg::ObjectRecordBase* ObjectRecordList::mutable_record_list(int index) {
  return record_list_.Mutable(index);
}
inline ::AFMsg::ObjectRecordBase* ObjectRecordList::add_record_list() {
  return record_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::AFMsg::ObjectRecordBase >&
ObjectRecordList::record_list() const {
  return record_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::AFMsg::ObjectRecordBase >*
ObjectRecordList::mutable_record_list() {
  return &record_list_;
}

// -------------------------------------------------------------------

// MultiObjectRecordList

// repeated .AFMsg.ObjectRecordList multi_player_record = 1;
inline int MultiObjectRecordList::multi_player_record_size() const {
  return multi_player_record_.size();
}
inline void MultiObjectRecordList::clear_multi_player_record() {
  multi_player_record_.Clear();
}
inline const ::AFMsg::ObjectRecordList& MultiObjectRecordList::multi_player_record(int index) const {
  return multi_player_record_.Get(index);
}
inline ::AFMsg::ObjectRecordList* MultiObjectRecordList::mutable_multi_player_record(int index) {
  return multi_player_record_.Mutable(index);
}
inline ::AFMsg::ObjectRecordList* MultiObjectRecordList::add_multi_player_record() {
  return multi_player_record_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::AFMsg::ObjectRecordList >&
MultiObjectRecordList::multi_player_record() const {
  return multi_player_record_;
}
inline ::google::protobuf::RepeatedPtrField< ::AFMsg::ObjectRecordList >*
MultiObjectRecordList::mutable_multi_player_record() {
  return &multi_player_record_;
}

// -------------------------------------------------------------------

// ObjectPropertyPBData

// required .AFMsg.Ident player_id = 1;
inline bool ObjectPropertyPBData::has_player_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ObjectPropertyPBData::set_has_player_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ObjectPropertyPBData::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ObjectPropertyPBData::clear_player_id() {
  if (player_id_ != NULL) player_id_->::AFMsg::Ident::Clear();
  clear_has_player_id();
}
inline const ::AFMsg::Ident& ObjectPropertyPBData::player_id() const {
  return player_id_ != NULL ? *player_id_ : *default_instance_->player_id_;
}
inline ::AFMsg::Ident* ObjectPropertyPBData::mutable_player_id() {
  set_has_player_id();
  if (player_id_ == NULL) player_id_ = new ::AFMsg::Ident;
  return player_id_;
}
inline ::AFMsg::Ident* ObjectPropertyPBData::release_player_id() {
  clear_has_player_id();
  ::AFMsg::Ident* temp = player_id_;
  player_id_ = NULL;
  return temp;
}
inline void ObjectPropertyPBData::set_allocated_player_id(::AFMsg::Ident* player_id) {
  delete player_id_;
  player_id_ = player_id;
  if (player_id) {
    set_has_player_id();
  } else {
    clear_has_player_id();
  }
}

// repeated .AFMsg.PropertyPBData property_list = 2;
inline int ObjectPropertyPBData::property_list_size() const {
  return property_list_.size();
}
inline void ObjectPropertyPBData::clear_property_list() {
  property_list_.Clear();
}
inline const ::AFMsg::PropertyPBData& ObjectPropertyPBData::property_list(int index) const {
  return property_list_.Get(index);
}
inline ::AFMsg::PropertyPBData* ObjectPropertyPBData::mutable_property_list(int index) {
  return property_list_.Mutable(index);
}
inline ::AFMsg::PropertyPBData* ObjectPropertyPBData::add_property_list() {
  return property_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::AFMsg::PropertyPBData >&
ObjectPropertyPBData::property_list() const {
  return property_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::AFMsg::PropertyPBData >*
ObjectPropertyPBData::mutable_property_list() {
  return &property_list_;
}

// -------------------------------------------------------------------

// ObjectRecordPBData

// required .AFMsg.Ident player_id = 1;
inline bool ObjectRecordPBData::has_player_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ObjectRecordPBData::set_has_player_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ObjectRecordPBData::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ObjectRecordPBData::clear_player_id() {
  if (player_id_ != NULL) player_id_->::AFMsg::Ident::Clear();
  clear_has_player_id();
}
inline const ::AFMsg::Ident& ObjectRecordPBData::player_id() const {
  return player_id_ != NULL ? *player_id_ : *default_instance_->player_id_;
}
inline ::AFMsg::Ident* ObjectRecordPBData::mutable_player_id() {
  set_has_player_id();
  if (player_id_ == NULL) player_id_ = new ::AFMsg::Ident;
  return player_id_;
}
inline ::AFMsg::Ident* ObjectRecordPBData::release_player_id() {
  clear_has_player_id();
  ::AFMsg::Ident* temp = player_id_;
  player_id_ = NULL;
  return temp;
}
inline void ObjectRecordPBData::set_allocated_player_id(::AFMsg::Ident* player_id) {
  delete player_id_;
  player_id_ = player_id;
  if (player_id) {
    set_has_player_id();
  } else {
    clear_has_player_id();
  }
}

// required bytes record_name = 2;
inline bool ObjectRecordPBData::has_record_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ObjectRecordPBData::set_has_record_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ObjectRecordPBData::clear_has_record_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ObjectRecordPBData::clear_record_name() {
  if (record_name_ != &::google::protobuf::internal::kEmptyString) {
    record_name_->clear();
  }
  clear_has_record_name();
}
inline const ::std::string& ObjectRecordPBData::record_name() const {
  return *record_name_;
}
inline void ObjectRecordPBData::set_record_name(const ::std::string& value) {
  set_has_record_name();
  if (record_name_ == &::google::protobuf::internal::kEmptyString) {
    record_name_ = new ::std::string;
  }
  record_name_->assign(value);
}
inline void ObjectRecordPBData::set_record_name(const char* value) {
  set_has_record_name();
  if (record_name_ == &::google::protobuf::internal::kEmptyString) {
    record_name_ = new ::std::string;
  }
  record_name_->assign(value);
}
inline void ObjectRecordPBData::set_record_name(const void* value, size_t size) {
  set_has_record_name();
  if (record_name_ == &::google::protobuf::internal::kEmptyString) {
    record_name_ = new ::std::string;
  }
  record_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ObjectRecordPBData::mutable_record_name() {
  set_has_record_name();
  if (record_name_ == &::google::protobuf::internal::kEmptyString) {
    record_name_ = new ::std::string;
  }
  return record_name_;
}
inline ::std::string* ObjectRecordPBData::release_record_name() {
  clear_has_record_name();
  if (record_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = record_name_;
    record_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ObjectRecordPBData::set_allocated_record_name(::std::string* record_name) {
  if (record_name_ != &::google::protobuf::internal::kEmptyString) {
    delete record_name_;
  }
  if (record_name) {
    set_has_record_name();
    record_name_ = record_name;
  } else {
    clear_has_record_name();
    record_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .AFMsg.RecordPBData record_list = 3;
inline int ObjectRecordPBData::record_list_size() const {
  return record_list_.size();
}
inline void ObjectRecordPBData::clear_record_list() {
  record_list_.Clear();
}
inline const ::AFMsg::RecordPBData& ObjectRecordPBData::record_list(int index) const {
  return record_list_.Get(index);
}
inline ::AFMsg::RecordPBData* ObjectRecordPBData::mutable_record_list(int index) {
  return record_list_.Mutable(index);
}
inline ::AFMsg::RecordPBData* ObjectRecordPBData::add_record_list() {
  return record_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::AFMsg::RecordPBData >&
ObjectRecordPBData::record_list() const {
  return record_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::AFMsg::RecordPBData >*
ObjectRecordPBData::mutable_record_list() {
  return &record_list_;
}

// -------------------------------------------------------------------

// ObjectRecordSwap

// required .AFMsg.Ident player_id = 1;
inline bool ObjectRecordSwap::has_player_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ObjectRecordSwap::set_has_player_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ObjectRecordSwap::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ObjectRecordSwap::clear_player_id() {
  if (player_id_ != NULL) player_id_->::AFMsg::Ident::Clear();
  clear_has_player_id();
}
inline const ::AFMsg::Ident& ObjectRecordSwap::player_id() const {
  return player_id_ != NULL ? *player_id_ : *default_instance_->player_id_;
}
inline ::AFMsg::Ident* ObjectRecordSwap::mutable_player_id() {
  set_has_player_id();
  if (player_id_ == NULL) player_id_ = new ::AFMsg::Ident;
  return player_id_;
}
inline ::AFMsg::Ident* ObjectRecordSwap::release_player_id() {
  clear_has_player_id();
  ::AFMsg::Ident* temp = player_id_;
  player_id_ = NULL;
  return temp;
}
inline void ObjectRecordSwap::set_allocated_player_id(::AFMsg::Ident* player_id) {
  delete player_id_;
  player_id_ = player_id;
  if (player_id) {
    set_has_player_id();
  } else {
    clear_has_player_id();
  }
}

// required bytes origin_record_name = 2;
inline bool ObjectRecordSwap::has_origin_record_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ObjectRecordSwap::set_has_origin_record_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ObjectRecordSwap::clear_has_origin_record_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ObjectRecordSwap::clear_origin_record_name() {
  if (origin_record_name_ != &::google::protobuf::internal::kEmptyString) {
    origin_record_name_->clear();
  }
  clear_has_origin_record_name();
}
inline const ::std::string& ObjectRecordSwap::origin_record_name() const {
  return *origin_record_name_;
}
inline void ObjectRecordSwap::set_origin_record_name(const ::std::string& value) {
  set_has_origin_record_name();
  if (origin_record_name_ == &::google::protobuf::internal::kEmptyString) {
    origin_record_name_ = new ::std::string;
  }
  origin_record_name_->assign(value);
}
inline void ObjectRecordSwap::set_origin_record_name(const char* value) {
  set_has_origin_record_name();
  if (origin_record_name_ == &::google::protobuf::internal::kEmptyString) {
    origin_record_name_ = new ::std::string;
  }
  origin_record_name_->assign(value);
}
inline void ObjectRecordSwap::set_origin_record_name(const void* value, size_t size) {
  set_has_origin_record_name();
  if (origin_record_name_ == &::google::protobuf::internal::kEmptyString) {
    origin_record_name_ = new ::std::string;
  }
  origin_record_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ObjectRecordSwap::mutable_origin_record_name() {
  set_has_origin_record_name();
  if (origin_record_name_ == &::google::protobuf::internal::kEmptyString) {
    origin_record_name_ = new ::std::string;
  }
  return origin_record_name_;
}
inline ::std::string* ObjectRecordSwap::release_origin_record_name() {
  clear_has_origin_record_name();
  if (origin_record_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = origin_record_name_;
    origin_record_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ObjectRecordSwap::set_allocated_origin_record_name(::std::string* origin_record_name) {
  if (origin_record_name_ != &::google::protobuf::internal::kEmptyString) {
    delete origin_record_name_;
  }
  if (origin_record_name) {
    set_has_origin_record_name();
    origin_record_name_ = origin_record_name;
  } else {
    clear_has_origin_record_name();
    origin_record_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes target_record_name = 3;
inline bool ObjectRecordSwap::has_target_record_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ObjectRecordSwap::set_has_target_record_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ObjectRecordSwap::clear_has_target_record_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ObjectRecordSwap::clear_target_record_name() {
  if (target_record_name_ != &::google::protobuf::internal::kEmptyString) {
    target_record_name_->clear();
  }
  clear_has_target_record_name();
}
inline const ::std::string& ObjectRecordSwap::target_record_name() const {
  return *target_record_name_;
}
inline void ObjectRecordSwap::set_target_record_name(const ::std::string& value) {
  set_has_target_record_name();
  if (target_record_name_ == &::google::protobuf::internal::kEmptyString) {
    target_record_name_ = new ::std::string;
  }
  target_record_name_->assign(value);
}
inline void ObjectRecordSwap::set_target_record_name(const char* value) {
  set_has_target_record_name();
  if (target_record_name_ == &::google::protobuf::internal::kEmptyString) {
    target_record_name_ = new ::std::string;
  }
  target_record_name_->assign(value);
}
inline void ObjectRecordSwap::set_target_record_name(const void* value, size_t size) {
  set_has_target_record_name();
  if (target_record_name_ == &::google::protobuf::internal::kEmptyString) {
    target_record_name_ = new ::std::string;
  }
  target_record_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ObjectRecordSwap::mutable_target_record_name() {
  set_has_target_record_name();
  if (target_record_name_ == &::google::protobuf::internal::kEmptyString) {
    target_record_name_ = new ::std::string;
  }
  return target_record_name_;
}
inline ::std::string* ObjectRecordSwap::release_target_record_name() {
  clear_has_target_record_name();
  if (target_record_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = target_record_name_;
    target_record_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ObjectRecordSwap::set_allocated_target_record_name(::std::string* target_record_name) {
  if (target_record_name_ != &::google::protobuf::internal::kEmptyString) {
    delete target_record_name_;
  }
  if (target_record_name) {
    set_has_target_record_name();
    target_record_name_ = target_record_name;
  } else {
    clear_has_target_record_name();
    target_record_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 row_origin = 4;
inline bool ObjectRecordSwap::has_row_origin() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ObjectRecordSwap::set_has_row_origin() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ObjectRecordSwap::clear_has_row_origin() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ObjectRecordSwap::clear_row_origin() {
  row_origin_ = 0;
  clear_has_row_origin();
}
inline ::google::protobuf::int32 ObjectRecordSwap::row_origin() const {
  return row_origin_;
}
inline void ObjectRecordSwap::set_row_origin(::google::protobuf::int32 value) {
  set_has_row_origin();
  row_origin_ = value;
}

// required int32 row_target = 5;
inline bool ObjectRecordSwap::has_row_target() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ObjectRecordSwap::set_has_row_target() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ObjectRecordSwap::clear_has_row_target() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ObjectRecordSwap::clear_row_target() {
  row_target_ = 0;
  clear_has_row_target();
}
inline ::google::protobuf::int32 ObjectRecordSwap::row_target() const {
  return row_target_;
}
inline void ObjectRecordSwap::set_row_target(::google::protobuf::int32 value) {
  set_has_row_target();
  row_target_ = value;
}

// -------------------------------------------------------------------

// ObjectRecordAddRow

// required .AFMsg.Ident player_id = 1;
inline bool ObjectRecordAddRow::has_player_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ObjectRecordAddRow::set_has_player_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ObjectRecordAddRow::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ObjectRecordAddRow::clear_player_id() {
  if (player_id_ != NULL) player_id_->::AFMsg::Ident::Clear();
  clear_has_player_id();
}
inline const ::AFMsg::Ident& ObjectRecordAddRow::player_id() const {
  return player_id_ != NULL ? *player_id_ : *default_instance_->player_id_;
}
inline ::AFMsg::Ident* ObjectRecordAddRow::mutable_player_id() {
  set_has_player_id();
  if (player_id_ == NULL) player_id_ = new ::AFMsg::Ident;
  return player_id_;
}
inline ::AFMsg::Ident* ObjectRecordAddRow::release_player_id() {
  clear_has_player_id();
  ::AFMsg::Ident* temp = player_id_;
  player_id_ = NULL;
  return temp;
}
inline void ObjectRecordAddRow::set_allocated_player_id(::AFMsg::Ident* player_id) {
  delete player_id_;
  player_id_ = player_id;
  if (player_id) {
    set_has_player_id();
  } else {
    clear_has_player_id();
  }
}

// required bytes record_name = 2;
inline bool ObjectRecordAddRow::has_record_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ObjectRecordAddRow::set_has_record_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ObjectRecordAddRow::clear_has_record_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ObjectRecordAddRow::clear_record_name() {
  if (record_name_ != &::google::protobuf::internal::kEmptyString) {
    record_name_->clear();
  }
  clear_has_record_name();
}
inline const ::std::string& ObjectRecordAddRow::record_name() const {
  return *record_name_;
}
inline void ObjectRecordAddRow::set_record_name(const ::std::string& value) {
  set_has_record_name();
  if (record_name_ == &::google::protobuf::internal::kEmptyString) {
    record_name_ = new ::std::string;
  }
  record_name_->assign(value);
}
inline void ObjectRecordAddRow::set_record_name(const char* value) {
  set_has_record_name();
  if (record_name_ == &::google::protobuf::internal::kEmptyString) {
    record_name_ = new ::std::string;
  }
  record_name_->assign(value);
}
inline void ObjectRecordAddRow::set_record_name(const void* value, size_t size) {
  set_has_record_name();
  if (record_name_ == &::google::protobuf::internal::kEmptyString) {
    record_name_ = new ::std::string;
  }
  record_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ObjectRecordAddRow::mutable_record_name() {
  set_has_record_name();
  if (record_name_ == &::google::protobuf::internal::kEmptyString) {
    record_name_ = new ::std::string;
  }
  return record_name_;
}
inline ::std::string* ObjectRecordAddRow::release_record_name() {
  clear_has_record_name();
  if (record_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = record_name_;
    record_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ObjectRecordAddRow::set_allocated_record_name(::std::string* record_name) {
  if (record_name_ != &::google::protobuf::internal::kEmptyString) {
    delete record_name_;
  }
  if (record_name) {
    set_has_record_name();
    record_name_ = record_name;
  } else {
    clear_has_record_name();
    record_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .AFMsg.RecordAddRowStruct row_data = 3;
inline int ObjectRecordAddRow::row_data_size() const {
  return row_data_.size();
}
inline void ObjectRecordAddRow::clear_row_data() {
  row_data_.Clear();
}
inline const ::AFMsg::RecordAddRowStruct& ObjectRecordAddRow::row_data(int index) const {
  return row_data_.Get(index);
}
inline ::AFMsg::RecordAddRowStruct* ObjectRecordAddRow::mutable_row_data(int index) {
  return row_data_.Mutable(index);
}
inline ::AFMsg::RecordAddRowStruct* ObjectRecordAddRow::add_row_data() {
  return row_data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::AFMsg::RecordAddRowStruct >&
ObjectRecordAddRow::row_data() const {
  return row_data_;
}
inline ::google::protobuf::RepeatedPtrField< ::AFMsg::RecordAddRowStruct >*
ObjectRecordAddRow::mutable_row_data() {
  return &row_data_;
}

// -------------------------------------------------------------------

// ObjectRecordRemove

// required .AFMsg.Ident player_id = 1;
inline bool ObjectRecordRemove::has_player_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ObjectRecordRemove::set_has_player_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ObjectRecordRemove::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ObjectRecordRemove::clear_player_id() {
  if (player_id_ != NULL) player_id_->::AFMsg::Ident::Clear();
  clear_has_player_id();
}
inline const ::AFMsg::Ident& ObjectRecordRemove::player_id() const {
  return player_id_ != NULL ? *player_id_ : *default_instance_->player_id_;
}
inline ::AFMsg::Ident* ObjectRecordRemove::mutable_player_id() {
  set_has_player_id();
  if (player_id_ == NULL) player_id_ = new ::AFMsg::Ident;
  return player_id_;
}
inline ::AFMsg::Ident* ObjectRecordRemove::release_player_id() {
  clear_has_player_id();
  ::AFMsg::Ident* temp = player_id_;
  player_id_ = NULL;
  return temp;
}
inline void ObjectRecordRemove::set_allocated_player_id(::AFMsg::Ident* player_id) {
  delete player_id_;
  player_id_ = player_id;
  if (player_id) {
    set_has_player_id();
  } else {
    clear_has_player_id();
  }
}

// required bytes record_name = 2;
inline bool ObjectRecordRemove::has_record_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ObjectRecordRemove::set_has_record_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ObjectRecordRemove::clear_has_record_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ObjectRecordRemove::clear_record_name() {
  if (record_name_ != &::google::protobuf::internal::kEmptyString) {
    record_name_->clear();
  }
  clear_has_record_name();
}
inline const ::std::string& ObjectRecordRemove::record_name() const {
  return *record_name_;
}
inline void ObjectRecordRemove::set_record_name(const ::std::string& value) {
  set_has_record_name();
  if (record_name_ == &::google::protobuf::internal::kEmptyString) {
    record_name_ = new ::std::string;
  }
  record_name_->assign(value);
}
inline void ObjectRecordRemove::set_record_name(const char* value) {
  set_has_record_name();
  if (record_name_ == &::google::protobuf::internal::kEmptyString) {
    record_name_ = new ::std::string;
  }
  record_name_->assign(value);
}
inline void ObjectRecordRemove::set_record_name(const void* value, size_t size) {
  set_has_record_name();
  if (record_name_ == &::google::protobuf::internal::kEmptyString) {
    record_name_ = new ::std::string;
  }
  record_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ObjectRecordRemove::mutable_record_name() {
  set_has_record_name();
  if (record_name_ == &::google::protobuf::internal::kEmptyString) {
    record_name_ = new ::std::string;
  }
  return record_name_;
}
inline ::std::string* ObjectRecordRemove::release_record_name() {
  clear_has_record_name();
  if (record_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = record_name_;
    record_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ObjectRecordRemove::set_allocated_record_name(::std::string* record_name) {
  if (record_name_ != &::google::protobuf::internal::kEmptyString) {
    delete record_name_;
  }
  if (record_name) {
    set_has_record_name();
    record_name_ = record_name;
  } else {
    clear_has_record_name();
    record_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated int32 remove_row = 3;
inline int ObjectRecordRemove::remove_row_size() const {
  return remove_row_.size();
}
inline void ObjectRecordRemove::clear_remove_row() {
  remove_row_.Clear();
}
inline ::google::protobuf::int32 ObjectRecordRemove::remove_row(int index) const {
  return remove_row_.Get(index);
}
inline void ObjectRecordRemove::set_remove_row(int index, ::google::protobuf::int32 value) {
  remove_row_.Set(index, value);
}
inline void ObjectRecordRemove::add_remove_row(::google::protobuf::int32 value) {
  remove_row_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
ObjectRecordRemove::remove_row() const {
  return remove_row_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
ObjectRecordRemove::mutable_remove_row() {
  return &remove_row_;
}

// -------------------------------------------------------------------

// PlayerPropertyBase

// repeated .AFMsg.PropertyPBData property_data_list = 1;
inline int PlayerPropertyBase::property_data_list_size() const {
  return property_data_list_.size();
}
inline void PlayerPropertyBase::clear_property_data_list() {
  property_data_list_.Clear();
}
inline const ::AFMsg::PropertyPBData& PlayerPropertyBase::property_data_list(int index) const {
  return property_data_list_.Get(index);
}
inline ::AFMsg::PropertyPBData* PlayerPropertyBase::mutable_property_data_list(int index) {
  return property_data_list_.Mutable(index);
}
inline ::AFMsg::PropertyPBData* PlayerPropertyBase::add_property_data_list() {
  return property_data_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::AFMsg::PropertyPBData >&
PlayerPropertyBase::property_data_list() const {
  return property_data_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::AFMsg::PropertyPBData >*
PlayerPropertyBase::mutable_property_data_list() {
  return &property_data_list_;
}

// -------------------------------------------------------------------

// PlayerRecordBase

// required string record_name = 1;
inline bool PlayerRecordBase::has_record_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerRecordBase::set_has_record_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerRecordBase::clear_has_record_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerRecordBase::clear_record_name() {
  if (record_name_ != &::google::protobuf::internal::kEmptyString) {
    record_name_->clear();
  }
  clear_has_record_name();
}
inline const ::std::string& PlayerRecordBase::record_name() const {
  return *record_name_;
}
inline void PlayerRecordBase::set_record_name(const ::std::string& value) {
  set_has_record_name();
  if (record_name_ == &::google::protobuf::internal::kEmptyString) {
    record_name_ = new ::std::string;
  }
  record_name_->assign(value);
}
inline void PlayerRecordBase::set_record_name(const char* value) {
  set_has_record_name();
  if (record_name_ == &::google::protobuf::internal::kEmptyString) {
    record_name_ = new ::std::string;
  }
  record_name_->assign(value);
}
inline void PlayerRecordBase::set_record_name(const char* value, size_t size) {
  set_has_record_name();
  if (record_name_ == &::google::protobuf::internal::kEmptyString) {
    record_name_ = new ::std::string;
  }
  record_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlayerRecordBase::mutable_record_name() {
  set_has_record_name();
  if (record_name_ == &::google::protobuf::internal::kEmptyString) {
    record_name_ = new ::std::string;
  }
  return record_name_;
}
inline ::std::string* PlayerRecordBase::release_record_name() {
  clear_has_record_name();
  if (record_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = record_name_;
    record_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PlayerRecordBase::set_allocated_record_name(::std::string* record_name) {
  if (record_name_ != &::google::protobuf::internal::kEmptyString) {
    delete record_name_;
  }
  if (record_name) {
    set_has_record_name();
    record_name_ = record_name;
  } else {
    clear_has_record_name();
    record_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .AFMsg.RecordPBData record_data_list = 2;
inline int PlayerRecordBase::record_data_list_size() const {
  return record_data_list_.size();
}
inline void PlayerRecordBase::clear_record_data_list() {
  record_data_list_.Clear();
}
inline const ::AFMsg::RecordPBData& PlayerRecordBase::record_data_list(int index) const {
  return record_data_list_.Get(index);
}
inline ::AFMsg::RecordPBData* PlayerRecordBase::mutable_record_data_list(int index) {
  return record_data_list_.Mutable(index);
}
inline ::AFMsg::RecordPBData* PlayerRecordBase::add_record_data_list() {
  return record_data_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::AFMsg::RecordPBData >&
PlayerRecordBase::record_data_list() const {
  return record_data_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::AFMsg::RecordPBData >*
PlayerRecordBase::mutable_record_data_list() {
  return &record_data_list_;
}

// -------------------------------------------------------------------

// PlayerRecordList

// repeated .AFMsg.PlayerRecordBase record_list = 1;
inline int PlayerRecordList::record_list_size() const {
  return record_list_.size();
}
inline void PlayerRecordList::clear_record_list() {
  record_list_.Clear();
}
inline const ::AFMsg::PlayerRecordBase& PlayerRecordList::record_list(int index) const {
  return record_list_.Get(index);
}
inline ::AFMsg::PlayerRecordBase* PlayerRecordList::mutable_record_list(int index) {
  return record_list_.Mutable(index);
}
inline ::AFMsg::PlayerRecordBase* PlayerRecordList::add_record_list() {
  return record_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::AFMsg::PlayerRecordBase >&
PlayerRecordList::record_list() const {
  return record_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::AFMsg::PlayerRecordBase >*
PlayerRecordList::mutable_record_list() {
  return &record_list_;
}

// -------------------------------------------------------------------

// MsgBase

// required .AFMsg.Ident player_id = 1;
inline bool MsgBase::has_player_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgBase::set_has_player_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgBase::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MsgBase::clear_player_id() {
  if (player_id_ != NULL) player_id_->::AFMsg::Ident::Clear();
  clear_has_player_id();
}
inline const ::AFMsg::Ident& MsgBase::player_id() const {
  return player_id_ != NULL ? *player_id_ : *default_instance_->player_id_;
}
inline ::AFMsg::Ident* MsgBase::mutable_player_id() {
  set_has_player_id();
  if (player_id_ == NULL) player_id_ = new ::AFMsg::Ident;
  return player_id_;
}
inline ::AFMsg::Ident* MsgBase::release_player_id() {
  clear_has_player_id();
  ::AFMsg::Ident* temp = player_id_;
  player_id_ = NULL;
  return temp;
}
inline void MsgBase::set_allocated_player_id(::AFMsg::Ident* player_id) {
  delete player_id_;
  player_id_ = player_id;
  if (player_id) {
    set_has_player_id();
  } else {
    clear_has_player_id();
  }
}

// required bytes msg_data = 2;
inline bool MsgBase::has_msg_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MsgBase::set_has_msg_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MsgBase::clear_has_msg_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MsgBase::clear_msg_data() {
  if (msg_data_ != &::google::protobuf::internal::kEmptyString) {
    msg_data_->clear();
  }
  clear_has_msg_data();
}
inline const ::std::string& MsgBase::msg_data() const {
  return *msg_data_;
}
inline void MsgBase::set_msg_data(const ::std::string& value) {
  set_has_msg_data();
  if (msg_data_ == &::google::protobuf::internal::kEmptyString) {
    msg_data_ = new ::std::string;
  }
  msg_data_->assign(value);
}
inline void MsgBase::set_msg_data(const char* value) {
  set_has_msg_data();
  if (msg_data_ == &::google::protobuf::internal::kEmptyString) {
    msg_data_ = new ::std::string;
  }
  msg_data_->assign(value);
}
inline void MsgBase::set_msg_data(const void* value, size_t size) {
  set_has_msg_data();
  if (msg_data_ == &::google::protobuf::internal::kEmptyString) {
    msg_data_ = new ::std::string;
  }
  msg_data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MsgBase::mutable_msg_data() {
  set_has_msg_data();
  if (msg_data_ == &::google::protobuf::internal::kEmptyString) {
    msg_data_ = new ::std::string;
  }
  return msg_data_;
}
inline ::std::string* MsgBase::release_msg_data() {
  clear_has_msg_data();
  if (msg_data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = msg_data_;
    msg_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MsgBase::set_allocated_msg_data(::std::string* msg_data) {
  if (msg_data_ != &::google::protobuf::internal::kEmptyString) {
    delete msg_data_;
  }
  if (msg_data) {
    set_has_msg_data();
    msg_data_ = msg_data;
  } else {
    clear_has_msg_data();
    msg_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .AFMsg.Ident player_Client_list = 3;
inline int MsgBase::player_client_list_size() const {
  return player_client_list_.size();
}
inline void MsgBase::clear_player_client_list() {
  player_client_list_.Clear();
}
inline const ::AFMsg::Ident& MsgBase::player_client_list(int index) const {
  return player_client_list_.Get(index);
}
inline ::AFMsg::Ident* MsgBase::mutable_player_client_list(int index) {
  return player_client_list_.Mutable(index);
}
inline ::AFMsg::Ident* MsgBase::add_player_client_list() {
  return player_client_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::AFMsg::Ident >&
MsgBase::player_client_list() const {
  return player_client_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::AFMsg::Ident >*
MsgBase::mutable_player_client_list() {
  return &player_client_list_;
}

// optional .AFMsg.Ident hash_ident = 4;
inline bool MsgBase::has_hash_ident() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MsgBase::set_has_hash_ident() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MsgBase::clear_has_hash_ident() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MsgBase::clear_hash_ident() {
  if (hash_ident_ != NULL) hash_ident_->::AFMsg::Ident::Clear();
  clear_has_hash_ident();
}
inline const ::AFMsg::Ident& MsgBase::hash_ident() const {
  return hash_ident_ != NULL ? *hash_ident_ : *default_instance_->hash_ident_;
}
inline ::AFMsg::Ident* MsgBase::mutable_hash_ident() {
  set_has_hash_ident();
  if (hash_ident_ == NULL) hash_ident_ = new ::AFMsg::Ident;
  return hash_ident_;
}
inline ::AFMsg::Ident* MsgBase::release_hash_ident() {
  clear_has_hash_ident();
  ::AFMsg::Ident* temp = hash_ident_;
  hash_ident_ = NULL;
  return temp;
}
inline void MsgBase::set_allocated_hash_ident(::AFMsg::Ident* hash_ident) {
  delete hash_ident_;
  hash_ident_ = hash_ident;
  if (hash_ident) {
    set_has_hash_ident();
  } else {
    clear_has_hash_ident();
  }
}

// -------------------------------------------------------------------

// Position

// required float x = 1;
inline bool Position::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Position::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Position::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Position::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float Position::x() const {
  return x_;
}
inline void Position::set_x(float value) {
  set_has_x();
  x_ = value;
}

// required float y = 2;
inline bool Position::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Position::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Position::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Position::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float Position::y() const {
  return y_;
}
inline void Position::set_y(float value) {
  set_has_y();
  y_ = value;
}

// required float z = 3;
inline bool Position::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Position::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Position::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Position::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline float Position::z() const {
  return z_;
}
inline void Position::set_z(float value) {
  set_has_z();
  z_ = value;
}

// -------------------------------------------------------------------

// ReqCommand

// required .AFMsg.Ident control_id = 1;
inline bool ReqCommand::has_control_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqCommand::set_has_control_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqCommand::clear_has_control_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqCommand::clear_control_id() {
  if (control_id_ != NULL) control_id_->::AFMsg::Ident::Clear();
  clear_has_control_id();
}
inline const ::AFMsg::Ident& ReqCommand::control_id() const {
  return control_id_ != NULL ? *control_id_ : *default_instance_->control_id_;
}
inline ::AFMsg::Ident* ReqCommand::mutable_control_id() {
  set_has_control_id();
  if (control_id_ == NULL) control_id_ = new ::AFMsg::Ident;
  return control_id_;
}
inline ::AFMsg::Ident* ReqCommand::release_control_id() {
  clear_has_control_id();
  ::AFMsg::Ident* temp = control_id_;
  control_id_ = NULL;
  return temp;
}
inline void ReqCommand::set_allocated_control_id(::AFMsg::Ident* control_id) {
  delete control_id_;
  control_id_ = control_id;
  if (control_id) {
    set_has_control_id();
  } else {
    clear_has_control_id();
  }
}

// required .AFMsg.ReqCommand.EGameCommandType command_id = 2;
inline bool ReqCommand::has_command_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqCommand::set_has_command_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqCommand::clear_has_command_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqCommand::clear_command_id() {
  command_id_ = 0;
  clear_has_command_id();
}
inline ::AFMsg::ReqCommand_EGameCommandType ReqCommand::command_id() const {
  return static_cast< ::AFMsg::ReqCommand_EGameCommandType >(command_id_);
}
inline void ReqCommand::set_command_id(::AFMsg::ReqCommand_EGameCommandType value) {
  assert(::AFMsg::ReqCommand_EGameCommandType_IsValid(value));
  set_has_command_id();
  command_id_ = value;
}

// optional bytes command_str_value = 3;
inline bool ReqCommand::has_command_str_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReqCommand::set_has_command_str_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReqCommand::clear_has_command_str_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReqCommand::clear_command_str_value() {
  if (command_str_value_ != &::google::protobuf::internal::kEmptyString) {
    command_str_value_->clear();
  }
  clear_has_command_str_value();
}
inline const ::std::string& ReqCommand::command_str_value() const {
  return *command_str_value_;
}
inline void ReqCommand::set_command_str_value(const ::std::string& value) {
  set_has_command_str_value();
  if (command_str_value_ == &::google::protobuf::internal::kEmptyString) {
    command_str_value_ = new ::std::string;
  }
  command_str_value_->assign(value);
}
inline void ReqCommand::set_command_str_value(const char* value) {
  set_has_command_str_value();
  if (command_str_value_ == &::google::protobuf::internal::kEmptyString) {
    command_str_value_ = new ::std::string;
  }
  command_str_value_->assign(value);
}
inline void ReqCommand::set_command_str_value(const void* value, size_t size) {
  set_has_command_str_value();
  if (command_str_value_ == &::google::protobuf::internal::kEmptyString) {
    command_str_value_ = new ::std::string;
  }
  command_str_value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqCommand::mutable_command_str_value() {
  set_has_command_str_value();
  if (command_str_value_ == &::google::protobuf::internal::kEmptyString) {
    command_str_value_ = new ::std::string;
  }
  return command_str_value_;
}
inline ::std::string* ReqCommand::release_command_str_value() {
  clear_has_command_str_value();
  if (command_str_value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = command_str_value_;
    command_str_value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReqCommand::set_allocated_command_str_value(::std::string* command_str_value) {
  if (command_str_value_ != &::google::protobuf::internal::kEmptyString) {
    delete command_str_value_;
  }
  if (command_str_value) {
    set_has_command_str_value();
    command_str_value_ = command_str_value;
  } else {
    clear_has_command_str_value();
    command_str_value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 command_value_int = 4;
inline bool ReqCommand::has_command_value_int() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ReqCommand::set_has_command_value_int() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ReqCommand::clear_has_command_value_int() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ReqCommand::clear_command_value_int() {
  command_value_int_ = GOOGLE_LONGLONG(0);
  clear_has_command_value_int();
}
inline ::google::protobuf::int64 ReqCommand::command_value_int() const {
  return command_value_int_;
}
inline void ReqCommand::set_command_value_int(::google::protobuf::int64 value) {
  set_has_command_value_int();
  command_value_int_ = value;
}

// optional float command_value_float = 5;
inline bool ReqCommand::has_command_value_float() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ReqCommand::set_has_command_value_float() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ReqCommand::clear_has_command_value_float() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ReqCommand::clear_command_value_float() {
  command_value_float_ = 0;
  clear_has_command_value_float();
}
inline float ReqCommand::command_value_float() const {
  return command_value_float_;
}
inline void ReqCommand::set_command_value_float(float value) {
  set_has_command_value_float();
  command_value_float_ = value;
}

// optional bytes command_value_str = 6;
inline bool ReqCommand::has_command_value_str() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ReqCommand::set_has_command_value_str() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ReqCommand::clear_has_command_value_str() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ReqCommand::clear_command_value_str() {
  if (command_value_str_ != &::google::protobuf::internal::kEmptyString) {
    command_value_str_->clear();
  }
  clear_has_command_value_str();
}
inline const ::std::string& ReqCommand::command_value_str() const {
  return *command_value_str_;
}
inline void ReqCommand::set_command_value_str(const ::std::string& value) {
  set_has_command_value_str();
  if (command_value_str_ == &::google::protobuf::internal::kEmptyString) {
    command_value_str_ = new ::std::string;
  }
  command_value_str_->assign(value);
}
inline void ReqCommand::set_command_value_str(const char* value) {
  set_has_command_value_str();
  if (command_value_str_ == &::google::protobuf::internal::kEmptyString) {
    command_value_str_ = new ::std::string;
  }
  command_value_str_->assign(value);
}
inline void ReqCommand::set_command_value_str(const void* value, size_t size) {
  set_has_command_value_str();
  if (command_value_str_ == &::google::protobuf::internal::kEmptyString) {
    command_value_str_ = new ::std::string;
  }
  command_value_str_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqCommand::mutable_command_value_str() {
  set_has_command_value_str();
  if (command_value_str_ == &::google::protobuf::internal::kEmptyString) {
    command_value_str_ = new ::std::string;
  }
  return command_value_str_;
}
inline ::std::string* ReqCommand::release_command_value_str() {
  clear_has_command_value_str();
  if (command_value_str_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = command_value_str_;
    command_value_str_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReqCommand::set_allocated_command_value_str(::std::string* command_value_str) {
  if (command_value_str_ != &::google::protobuf::internal::kEmptyString) {
    delete command_value_str_;
  }
  if (command_value_str) {
    set_has_command_value_str();
    command_value_str_ = command_value_str;
  } else {
    clear_has_command_value_str();
    command_value_str_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .AFMsg.Ident command_value_object = 7;
inline bool ReqCommand::has_command_value_object() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ReqCommand::set_has_command_value_object() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ReqCommand::clear_has_command_value_object() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ReqCommand::clear_command_value_object() {
  if (command_value_object_ != NULL) command_value_object_->::AFMsg::Ident::Clear();
  clear_has_command_value_object();
}
inline const ::AFMsg::Ident& ReqCommand::command_value_object() const {
  return command_value_object_ != NULL ? *command_value_object_ : *default_instance_->command_value_object_;
}
inline ::AFMsg::Ident* ReqCommand::mutable_command_value_object() {
  set_has_command_value_object();
  if (command_value_object_ == NULL) command_value_object_ = new ::AFMsg::Ident;
  return command_value_object_;
}
inline ::AFMsg::Ident* ReqCommand::release_command_value_object() {
  clear_has_command_value_object();
  ::AFMsg::Ident* temp = command_value_object_;
  command_value_object_ = NULL;
  return temp;
}
inline void ReqCommand::set_allocated_command_value_object(::AFMsg::Ident* command_value_object) {
  delete command_value_object_;
  command_value_object_ = command_value_object;
  if (command_value_object) {
    set_has_command_value_object();
  } else {
    clear_has_command_value_object();
  }
}

// optional int32 row = 8;
inline bool ReqCommand::has_row() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ReqCommand::set_has_row() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ReqCommand::clear_has_row() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ReqCommand::clear_row() {
  row_ = 0;
  clear_has_row();
}
inline ::google::protobuf::int32 ReqCommand::row() const {
  return row_;
}
inline void ReqCommand::set_row(::google::protobuf::int32 value) {
  set_has_row();
  row_ = value;
}

// optional int32 col = 9;
inline bool ReqCommand::has_col() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ReqCommand::set_has_col() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ReqCommand::clear_has_col() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ReqCommand::clear_col() {
  col_ = 0;
  clear_has_col();
}
inline ::google::protobuf::int32 ReqCommand::col() const {
  return col_;
}
inline void ReqCommand::set_col(::google::protobuf::int32 value) {
  set_has_col();
  col_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace AFMsg

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::AFMsg::ReqCommand_EGameCommandType>() {
  return ::AFMsg::ReqCommand_EGameCommandType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_AFMsgBase_2eproto__INCLUDED

